<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Donut Miner „ÉÑ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Include Tone.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        /* =============================================================== */
        /* KISSAKI/TAMAGOTCHI AESTHETIC STYLING                            */
        /* =============================================================== */

        /* Custom Font - Nunito is a good match for the cute, rounded look */
        @import url('https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700;800;900&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Comic+Neue:wght@400;700&display=swap'); /* Changed to Comic Neue */
        @import url('https://fonts.googleapis.com/css2?family=Luckiest+Guy&display=swap'); /* NEW: Added Luckiest Guy font */
        
        /* This is the "browser" background, outside the phone */
        body {
            font-family: 'Nunito', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            overscroll-behavior: none; /* Prevents "pull-to-refresh" */
            
            /* Apply app-shell styling directly to body */
            background-color: #FFC0CB; /* Soft Pink */
            background-image: url("data:image/svg+xml,%3Csvg width='100' height='100' viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'%3E%3Cg opacity='0.7'%3E%3Crect x='10' y='10' width='3' height='10' fill='%23FFD700' transform='rotate(25 11.5 15)' /%3E%3Crect x='60' y='30' width='3' height='10' fill='%23FF69B4' transform='rotate(140 61.5 35)' /%3E%3Crect x='30' y='70' width='3' height='10' fill='%2390EE90' transform='rotate(70 31.5 75)' /%3E%3Crect x='80' y='85' width='3' height='10' fill='%2387CEEB' transform='rotate(210 81.5 90)' /%3E%3Crect x='5' y='45' width='3' height='10' fill='%23FFD700' transform='rotate(100 6.5 50)' /%3E%3Crect x='90' y='5' width='3' height='10' fill='%23FF69B4' transform='rotate(300 91.5 10)' /%3E%3C/g%3E%3C/svg%3E"), 
                            linear-gradient(135deg, #FFC0CB 0%, #FFDDE1 100%); /* Soft Pink base */
            background-size: 200px 200px, cover; /* Adjust size for sprinkles, cover for gradient */
            background-blend-mode: overlay, normal;
            background-attachment: fixed;
            color: #333333; /* Dark gray for general text */
            
            /* Ensure the body takes full viewport height and manages overflow */
            min-height: 100vh;
            display: flex; /* Use flexbox to organize main content and nav */
            flex-direction: column; /* Stack content vertically */
            padding: 0; /* Remove padding */
            margin: 0; /* Remove margin */
        }

        /* Custom Colors inspired by Tamagotchi */
        /* Changed to pale butter yellow */
        .bg-tamagotchi-bg-light { background-color: #FFFACD; } 
        .text-tamagotchi-dark { color: #333333; } /* General dark text */
        .text-tamagotchi-pink-dark { color: #E75480; } /* Stronger, cuter pink for accents/headings */
        .text-tamagotchi-pink-light { color: #FF9AA2; } /* Lighter pink for accents */
        
        /* Button colors */
        .bg-tamagotchi-button-pink { 
            background: linear-gradient(to bottom, #FFDDE1, #E75480); /* Puffy pink gradient */
            color: white;
            font-weight: 800;
            border: 2px solid #C04A70; /* Darker border for depth */
        }
        .bg-tamagotchi-button-teal { 
            background: linear-gradient(to bottom, #B3F0E6, #66CCBF); /* Teal gradient */
            color: white;
            font-weight: 800;
            border: 2px solid #50A89C; /* Darker border for depth */
        }
        .bg-tamagotchi-button-pink:active, .bg-tamagotchi-button-teal:active {
            transform: translateY(1px); /* Simple press effect */
            box-shadow: none;
        }

        /* Border/Card colors */
        .border-tamagotchi-subtle { border-color: #E0E0E0; } /* Light gray border */
        /* Changed to pale butter yellow */
        .bg-tamagotchi-card { 
            background-color: #FFFACD; /* Pale Butter Yellow for cards */
            border: 2px solid #E0E0E0; /* Subtle border */
        }
        .border-tamagotchi-accent-pink { border-color: #FF9AA2; /* Pink accent border */
        }

        /* General rounding */
        .rounded-tamagotchi-lg { border-radius: 20px; } /* More pronounced rounding for cards/buttons */
        .rounded-tamagotchi-md { border-radius: 14px; } /* Medium rounding */
        .rounded-tamagotchi-full { border-radius: 9999px; } /* Full rounding for circular elements */

        /* Shadows (softer, toy-like) */
        .shadow-tamagotchi { box-shadow: 0px 6px 15px rgba(0, 0, 0, 0.1); } /* More pronounced, softer shadow */
        
        .nav-icon span {
            font-size: 32px; /* Large emoji */
            color: #A0A0A0; /* Soft gray for inactive icons */
            transition: color 0.2s ease-in-out, transform 0.2s ease-in-out;
        }
        .nav-icon.active span {
            color: #E75480; /* Stronger pink for active icon */
            transform: scale(1.1);
        }

        /* Style for the 3D canvas */
        #cookie-canvas {
            width: 100%;
            height: 100%;
            max-width: 400px; /* Keep max width to prevent distortion on very wide screens */
            max-height: 400px; /* Keep max height */
            cursor: grab;
            touch-action: none;
            position: relative; /* Ensure canvas is positioned above static */
            z-index: 20; /* Higher than static */
            margin: auto; /* Center the canvas */
        }
        #cookie-canvas:active {
            cursor: grabbing;
        }

        /* Glaze color button styling */
        .color-cycle-button { /* Applied to both glaze and sprinkle buttons */
            position: absolute; /* Will be positioned relative to parent */
            bottom: 10px;
            width: 32px; /* Smaller width */
            height: 32px; /* Smaller height */
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px; /* Smaller font size */
            border-radius: 50%; /* Circular button */
            cursor: pointer;
            border: 2px solid #E0E0E0; /* Subtle border */
            background-color: #f0f0f0; /* Default light background */
            box-shadow: 0px 2px 5px rgba(0,0,0,0.2);
            transition: transform 0.1s ease-in-out, background-color 0.2s;
            z-index: 30; /* Ensure it's above other elements in the container */
        }
        .color-cycle-button:active {
            transform: translateY(1px);
            box-shadow: none;
        }
        /* Specific positioning */
        #glaze-color-button {
            right: 8px; /* Adjusted right spacing */
        }
        #sprinkle-color-button { /* New button */
            right: 48px; /* 8px (glaze) + 32px (button width) + 8px (gap) */
        }
        #donut-base-color-button { /* NEW */
            right: 88px; /* 48px (sprinkle) + 32px (button width) + 8px (gap) */
        }


        /* =============================================================== */
        /* GLITCHY STATIC TV EFFECT (Pale Butter Yellow Background)      */
        /* =============================================================== */

        .glitch-static {
            position: relative; /* Needed for pseudo-elements */
            overflow: hidden;
            background-color: #FFFACD !important; /* Pale Butter Yellow background - Added !important to override */
        }

        .glitch-static::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                linear-gradient(rgba(240, 230, 200, 0.4) 1px, transparent 1px), /* Softer static lines, matching yellow */
                linear-gradient(90deg, rgba(240, 230, 200, 0.4) 1px, transparent 1px);
            background-size: 4px 4px; /* Slightly larger static pixels */
            animation: static-flicker 0.5s infinite alternate, static-move 3s steps(10) infinite; /* Slower animations */
            opacity: 0.6; /* Softer static */
            pointer-events: none; /* Allows clicks/interactions with elements behind it */
            z-index: 15; /* Below donut, above container bg */
        }

        .glitch-static::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                to bottom,
                transparent 0%,
                rgba(240, 230, 200, 0.2) 50%, /* Softer yellow scanline */
                transparent 100%
            );
            mix-blend-mode: overlay; /* Creates light distortion effect */
            animation: scanline 8s linear infinite; /* Slower scanline */
            opacity: 0.3; /* Slightly more pronounced scanline */
            pointer-events: none;
            z-index: 16; /* Slightly above main static */
        }

        @keyframes static-flicker {
            0% { background-position: 0 0; opacity: 0.6; }
            50% { background-position: 8px 8px; opacity: 0.5; } /* Larger displacement for flicker */
            100% { background-position: 0 0; opacity: 0.7; }
        }

        @keyframes static-move {
            0% { transform: translate(0, 0); }
            100% { transform: translate(0, 100%); }
        }

        @keyframes scanline {
            0% { background-position: 0 0; }
            100% { background-position: 0 100%; }
        }

        /* =============================================================== */
        /* FALLING SNOW (GREY PIXELS) EFFECT                              */
        /* =============================================================== */
        .falling-snow {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 17; /* Above static, below donut */
            overflow: hidden; /* Ensures snowflakes don't go outside */
        }

        .falling-snow::before,
        .falling-snow::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                /* Create many small grey "pixels" */
                radial-gradient(circle at 10% 20%, #A0A0A0 1px, transparent 1px),
                radial-gradient(circle at 70% 80%, #C0C0C0 1px, transparent 1px),
                radial-gradient(circle at 30% 60%, #B0B0B0 1px, transparent 1px),
                radial-gradient(circle at 90% 10%, #E0E0E0 1px, transparent 1px),
                radial-gradient(circle at 50% 40%, #D0D0D0 1px, transparent 1px),
                radial-gradient(circle at 20% 90%, #F0F0F0 1px, transparent 1px),
                radial-gradient(circle at 80% 30%, #A0A0A0 1px, transparent 1px),
                radial-gradient(circle at 40% 70%, #C0C0C0 1px, transparent 1px),
                radial-gradient(circle at 60% 5%, #B0B0B0 1px, transparent 1px),
                radial-gradient(circle at 5% 50%, #E0E0E0 1px, transparent 1px),
                radial-gradient(circle at 95% 45%, #D0D0D0 1px, transparent 1px);
            background-repeat: repeat;
            background-size: 20px 20px; /* Control the density */
            animation: snowfall 10s linear infinite; /* Slower fall */
            opacity: 0.7; /* Make them subtle */
        }

        .falling-snow::after {
            animation-delay: 5s; /* Stagger the animation for more continuous effect */
            background-size: 25px 25px; /* Different size for variety */
            opacity: 0.6;
            filter: blur(0.5px); /* Slight blur for depth */
        }

        @keyframes snowfall {
            0% { transform: translateY(-100%); }
            100% { transform: translateY(100%); }
        }

        /* =============================================================== */
        /* SCROLLING TICKER                                                */
        /* =============================================================== */
        .ticker-wrap {
            width: 100%;
            overflow: hidden;
            background-color: #333; /* Dark background */
            padding: 4px 0; /* Vertical padding */
            border-top: 2px solid #555;
            border-bottom: 2px solid #555;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
        }
        
        /* Specific margins for top and bottom tickers */
        #top-ticker { margin-bottom: 8px; }
        #bottom-ticker { margin-top: 8px; }


        .ticker-move {
            display: inline-block;
            white-space: nowrap;
            animation: scroll-ticker 20s linear infinite; /* Adjust duration for speed */
            color: #FFFACD; /* Pale Butter Yellow text */
            font-size: 14px;
            font-weight: bold;
            font-family: 'Comic Neue', cursive; /* Match other text */
            text-shadow: 1px 1px 1px rgba(0,0,0,0.5);
        }

        .ticker-move-reverse {
            display: inline-block;
            white-space: nowrap;
            animation: scroll-ticker-reverse 20s linear infinite; /* Adjust duration for speed */
            color: #FFFACD; /* Pale Butter Yellow text */
            font-size: 14px;
            font-weight: bold;
            font-family: 'Comic Neue', cursive; /* Match other text */
            text-shadow: 1px 1px 1px rgba(0,0,0,0.5);
        }

        @keyframes scroll-ticker {
            0% { transform: translateX(0%); } /* Start visible */
            100% { transform: translateX(-50%); } /* Move halfway, showing the duplicated text */
        }

        @keyframes scroll-ticker-reverse {
            0% { transform: translateX(-50%); } /* Start halfway */
            100% { transform: translateX(0%); } /* Move back to start */
        }
        
        /* =============================================================== */
        /* DARK MODE STYLING                                               */
        /* =============================================================== */

        /* Chocolate brown background */
        body.dark { /* Changed from #app-shell.dark to body.dark */
            background-color: #5C3317; /* Chocolate Brown */
            background-image: url("data:image/svg+xml,%3Csvg width='20' height='20' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='%236B4A34' fill-opacity='0.4'%3E%3Cpath d='M10 0L0 10l10 10 10-10z'/%3E%3Cpath d='M0 10L10 20l10-10L10 0z'/%3E%3C/g%3E%3C/svg%3E"), 
                            linear-gradient(135deg, #5C3317 0%, #3D2B1F 100%);
        }

        /* Dark cards */
        body.dark .bg-tamagotchi-card { /* Changed from #app-shell.dark to body.dark */
            background-color: #3D2B1F; /* Dark, rich brown */
            border-color: #4A3A2A; /* Darker border */
        }
        
        /* Light text for dark backgrounds */
        body.dark .text-tamagotchi-dark { color: #F5E6C1; } /* Creamy white text */
        body.dark .text-gray-500 { color: #A8998A; } /* Lighter, desaturated brown text */
        body.dark .text-gray-600 { color: #B8A99A; }
        
        /* Pinks can stay, they pop nicely on brown */
        body.dark .text-tamagotchi-pink-dark { color: #FF9AA2; } /* Lighten the pink a bit */

        /* Glitch background */
        body.dark .glitch-static { /* Changed from #app-shell.dark to body.dark */
            background-color: #3D2B1F !important; /* Dark brown */
        }
        body.dark .glitch-static::before { /* Changed from #app-shell.dark to body.dark */
            background: 
                linear-gradient(rgba(150, 130, 110, 0.4) 1px, transparent 1px),
                linear-gradient(90deg, rgba(150, 130, 110, 0.4) 1px, transparent 1px);
        }
        body.dark .glitch-static::after { /* Changed from #app-shell.dark to body.dark */
            background: linear-gradient(
                to bottom,
                transparent 0%,
                rgba(150, 130, 110, 0.2) 50%,
                transparent 100%
            );
        }
        
        /* Falling snow (grey pixels) will look good on dark */
        body.dark .falling-snow::before { /* Changed from #app-shell.dark to body.dark */
            opacity: 0.4;
        }
        body.dark .falling-snow::after { /* Changed from #app-shell.dark to body.dark */
            opacity: 0.3;
        }

        /* Subtle borders */
        body.dark .border-tamagotchi-subtle { border-color: #4A3A2A; } /* Changed from #app-shell.dark to body.dark */
        
        /* Light-on-dark for nav */
        body.dark .nav-icon span { /* Changed from #app-shell.dark to body.dark */
            color: #A8998A; /* Lighter inactive icon */
        }
        body.dark .nav-icon.active span { /* Changed from #app-shell.dark to body.dark */
            color: #FF9AA2; /* Lighter active pink */
        }
        
        /* Color cycle button */
        body.dark .color-cycle-button { /* Changed from #app-shell.dark to body.dark */
            background-color: #3D2B1F;
            border-color: #4A3A2A;
            color: #F5E6C1; /* Light text */
        }
        
        /* App background for sticky footer */
        body.dark .bg-tamagotchi-bg-light { /* Changed from #app-shell.dark to body.dark */
            background-color: #3D2B1F; /* Dark brown */
        }

        /* NEW: Zoom Slider Styling */
        .zoom-slider {
            position: absolute;
            top: 50%;
            right: 8px; /* Adjusted to match new button spacing */
            transform: translateY(-50%); /* Center vertically */
            width: 16px; /* Track thickness */
            height: 100px; /* Track length */
            -webkit-appearance: none;
            appearance: none;
            writing-mode: vertical-lr; /* Make it vertical */
            direction: ltr;
            background: rgba(0, 0, 0, 0.1);
            border-radius: 8px; /* Slightly smaller border radius */
            z-index: 30;
            padding: 0;
            transition: background 0.2s;
        }
        /* Dark mode style for slider */
        body.dark .zoom-slider { /* Changed from #app-shell.dark to body.dark */
            background: rgba(255, 255, 255, 0.2);
        }

        /* Thumb styling */
        .zoom-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 22px; /* Touch target */
            height: 22px;
            background: #FFFACD; /* Pale Butter Yellow */
            border-radius: 50%;
            border: 2px solid #E75480; /* Pink border */
            cursor: grab;
        }
        .zoom-slider::-moz-range-thumb {
            width: 22px;
            height: 22px;
            background: #FFFACD;
            border-radius: 50%;
            border: 2px solid #E75480;
            cursor: grab;
        }
        /* Dark mode thumb */
        body.dark .zoom-slider::-webkit-slider-thumb { /* Changed from #app-shell.dark to body.dark */
            background: #3D2B1F; /* Dark brown */
            border-color: #FF9AA2; /* Lighter pink */
        }
        body.dark .zoom-slider::-moz-range-thumb { /* Changed from #app-shell.dark to body.dark */
            background: #3D2B1F;
            border-color: #FF9AA2;
        }
        /* END NEW STYLES */

    </style>
</head>
<body class="text-tamagotchi-dark">
        
    <main class="flex-grow flex flex-col px-3 pt-4 pb-1 overflow-y-auto max-w-lg mx-auto w-full"> <!-- Added max-w-lg mx-auto w-full for content centering --><div class="flex justify-between items-center mb-2">
            <div class="flex flex-col">
                <h1 class="text-3xl font-black text-tamagotchi-pink-dark" style="font-family: 'Luckiest Guy', cursive;">Donut Miner</h1>
                
                <!-- NEW: Profile Name Section (MOVED & SHRUNK) --><div class="bg-tamagotchi-card rounded-tamagotchi-lg shadow-tamagotchi p-2 flex items-center space-x-3 mt-1">
                    <div>
                        <div id="player-profile-name" class="font-extrabold text-sm truncate text-tamagotchi-dark">DonutEnthusiast_123</div>
                    </div>
                </div>
                <!-- END: Profile Name Section --></div>
            <div class="grid grid-cols-2 gap-1 self-start"> <!-- MODIFIED: Changed to grid --><!-- Row 1 --><button id="dark-mode-toggle-button" class="bg-tamagotchi-button-teal text-white text-base w-8 h-8 flex items-center justify-center rounded-tamagotchi-md shadow-tamagotchi active:opacity-80"> <!-- MODIFIED: Size/Text -->üåô
                </button>
                <button id="info-button" class="bg-tamagotchi-button-pink text-white text-base w-8 h-8 flex items-center justify-center rounded-tamagotchi-md shadow-tamagotchi active:opacity-80"> <!-- MODIFIED: Size/Text & MOVED -->‚ùì
                </button>
                <!-- Row 2 --><button id="music-toggle-button" class="bg-tamagotchi-button-pink text-white text-base w-8 h-8 flex items-center justify-center rounded-tamagotchi-md shadow-tamagotchi active:opacity-80"> <!-- MODIFIED: Size/Text -->üîá
                </button>
                <button id="sfx-toggle-button" class="bg-tamagotchi-button-teal text-white text-base w-8 h-8 flex items-center justify-center rounded-tamagotchi-md shadow-tamagotchi active:opacity-80"> <!-- MODIFIED: Size/Text -->üîä
                </button>
            </div>
        </div>

        <!-- =============================================================== --><!-- GLAZERY VIEW (Restored)                                       --><!-- =============================================================== --><div id="view-glazery" class="flex-grow flex flex-col">
            <!-- REMOVED: Glazery h2 Subtitle --><!-- REMOVED: Profile Name Section --><div class="bg-tamagotchi-card rounded-tamagotchi-lg shadow-tamagotchi p-2 grid grid-cols-3 gap-2">
                <div class="text-center">
                    <div class="text-xs text-gray-500 font-semibold">King Glazer</div>
                    <div id="bakery-king-status" class="font-extrabold text-sm truncate text-tamagotchi-dark">None</div>
                </div>
                <div class="text-center">
                    <div class="text-xs text-gray-500 font-semibold">Glazed</div>
                    <div class="font-extrabold text-sm text-tamagotchi-dark">üç© <span id="bakery-cps">0.00</span></div>
                </div>
                <div class="text-center">
                    <div class="text-xs text-gray-500 font-semibold">Glaze Time</div>
                    <div class="font-extrabold text-sm text-tamagotchi-dark"><span id="bakery-baked">00:00:00</span></div>
                </div>
            </div>

            <!-- MOVED: Second Row of Stats DIV was here --><div id="top-ticker" class="ticker-wrap" style="margin-bottom: 4px; margin-top: 8px;"> <!-- MODIFIED: Added margin-top --><div class="ticker-move">
                    <!-- UPDATED TEXT --><span>Glaze price doubles each time a new Glazer takes over, and price cools down to $0 over 1 hour. ... Glaze price doubles each time a new Glazer takes over, and price cools down to $0 over 1 hour. ... </span>
                </div>
            </div>

            <div id="cookie-rain-container" class="relative h-64 flex items-center justify-center overflow-hidden bg-tamagotchi-card rounded-tamagotchi-lg shadow-tamagotchi glitch-static">
                <div class="falling-snow"></div>
                <canvas id="cookie-canvas"></canvas>
                <button id="glaze-color-button" class="color-cycle-button shadow-tamagotchi bg-white text-tamagotchi-dark">üé®</button>
                <button id="sprinkle-color-button" class="color-cycle-button shadow-tamagotchi bg-white text-tamagotchi-dark">üåà</button> <!-- NEW: Sprinkle color button --><button id="donut-base-color-button" class="color-cycle-button shadow-tamagotchi bg-white text-tamagotchi-dark">üç©</button> <!-- NEW: Donut base color button --><!-- NEW: Zoom Slider --><input id="glazery-zoom-slider" type="range" class="zoom-slider">
            </div>

            <div id="bottom-ticker" class="ticker-wrap" style="margin-top: 4px;">
                <div class="ticker-move-reverse">
                    <!-- UPDATED TEXT --><span>Glaze price doubles each time a new Glazer takes over, and price cools down to $0 over 1 hour. ... Glaze price doubles each time a new Glazer takes over, and price cools down to $0 over 1 hour. ... </span>
                </div>
            </div>
            
            <div class="bg-tamagotchi-card text-tamagotchi-dark p-2 rounded-tamagotchi-lg shadow-tamagotchi">
                <div class="flex justify-between items-center">
                    <div>
                        <div class="text-xs font-semibold text-gray-600">Glaze Price</div>
                        <div class="text-xl font-extrabold text-tamagotchi-dark">$23.23</div>
                        <div class="text-xs text-gray-500">$400.00 available</div>
                    </div>
                    <button id="bakery-action-button" class="bg-tamagotchi-button-pink text-white py-2 px-6 rounded-tamagotchi-md text-sm font-bold active:opacity-80 disabled:opacity-50 shadow-tamagotchi">
                        Glaze
                    </button>
                </div>
            </div>

            <!-- NEW: Second Row of Stats --><div class="bg-tamagotchi-card rounded-tamagotchi-lg shadow-tamagotchi p-2 grid grid-cols-3 gap-2 mt-2">
                <div class="text-center">
                    <div class="text-xs text-gray-500 font-semibold">Donut Balance</div>
                    <div id="player-donut-balance" class="font-extrabold text-sm truncate text-tamagotchi-dark">0</div>
                </div>
                <div class="text-center">
                    <div class="text-xs text-gray-500 font-semibold">Total Glaze Time</div>
                    <div id="player-total-glaze-time" class="font-extrabold text-sm text-tamagotchi-dark">00:00:00</div>
                </div>
                <div class="text-center">
                    <div class="text-xs text-gray-500 font-semibold">% Mined</div>
                    <div class="font-extrabold text-sm text-tamagotchi-dark"><span id="player-percent-mined">0.00</span>%</div>
                </div>
            </div>

        </div>

        <!-- =============================================================== --><!-- ABOUT VIEW (Restored)                                         --><!-- =============================================================== --><!-- REMOVED view-about DIV --><!-- BAKERY VIEW REMOVED --></main>

    <!-- REMOVED nav ELEMENT --><!-- NEW INFO MODAL --><div id="info-modal-overlay" class="fixed inset-0 bg-black bg-opacity-50 z-40 hidden"></div>
    <div id="info-modal" class="fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-tamagotchi-card rounded-tamagotchi-lg shadow-tamagotchi p-4 z-50 hidden w-11/12 max-w-xs text-tamagotchi-dark overflow-y-auto" style="max-height: 90vh;">
        <div class="flex justify-between items-center mb-2">
            <h3 class="text-xl font-bold text-tamagotchi-pink-dark">Info</h3>
            <button id="info-modal-close" class="text-2xl font-bold text-gray-500 hover:text-tamagotchi-pink-dark">&times;</button>
        </div>
        <!-- CONTENT MOVED FROM 'ABOUT' TAB --><div class="space-y-3">
            <!-- UPDATED INFO TEXT --><div class="bg-tamagotchi-card rounded-tamagotchi-lg shadow-tamagotchi p-4 space-y-4 text-tamagotchi-dark">
                <p class="font-bold text-lg" style="font-family: 'Comic Neue', cursive;">
                    Hello and welcome to Donut Miner!
                </p>
                <p class="text-sm">
                    Pay the Glaze Price to become <strong>King Glazer</strong> and earn <strong>100%</strong> of the $DONUT emissions until you are replaced.
                </p>
                <p class="text-sm">
                    Glaze price doubles each time a new Glazer takes over, and price cools down to $0 over 1 hour.
                </p>
            </div>
            <!-- END UPDATED INFO TEXT --><!-- NEW: Global Donut Stats --><h3 class="text-xl font-bold text-tamagotchi-pink-dark pt-2">Global Donut Stats</h3>
            <div class="bg-tamagotchi-card rounded-tamagotchi-lg shadow-tamagotchi p-4 space-y-3 text-tamagotchi-dark">
                
                <div class="flex justify-between items-center">
                    <span class="text-sm font-semibold text-gray-600">Total Donut Supply</span>
                    <span id="modal-total-supply" class="font-extrabold text-tamagotchi-dark">üç© 0</span>
                </div>
                
                <div class="flex justify-between items-center">
                    <span class="text-sm font-semibold text-gray-600">Total % Mined</span>
                    <span id="modal-percent-mined" class="font-extrabold text-tamagotchi-dark">0.00%</span>
                </div>

                <div class="flex justify-between items-center">
                    <span class="text-sm font-semibold text-gray-600">Time Until Halving</span>
                    <span id="modal-next-halving" class="font-extrabold text-tamagotchi-dark">--:--:--</span>
                </div>

                <div class="flex justify-between items-center">
                    <span class="text-sm font-semibold text-gray-600">Total Miners</span>
                    <span id="modal-total-miners" class="font-extrabold text-tamagotchi-dark">üë§ 0</span>
                </div>

            </div>
            <!-- END NEW SECTION --></div>
        <!-- END MOVED CONTENT --></div>

<script>
        document.addEventListener('DOMContentLoaded', () => {

            // ===============================================================
            // GAME STATE
            // ===============================================================
            
            const state = {
                // Player State
                player: {
                    cookies: 1000000,
                    isBakerKing: false,
                    claimableBakeryCookies: 0,
                    totalBakedCookies: 0,
                    glazeStartTime: null,
                    totalGlazeTimeMs: 0, // NEW: Track total time
                },
                // Global Game State
                global: {
                    emissionRate: 10,
                    totalCookiesCreated: 0,
                    nextHalvingAt: 1000000,
                    totalDonutSupply: 1000000000,
                    totalMiners: 1234,
                },
                // UI State
                ui: {
                    // REMOVED activeView
                    isDarkMode: false,
                    isSfxMuted: false
                }
            };

            // ===============================================================
            // DOM ELEMENTS
            // ===============================================================
            const dom = {
                // REMOVED views property
                // REMOVED aboutPage property
                // REMOVED nav property
                glazery: {
                    kingStatus: document.getElementById('bakery-king-status'),
                    cps: document.getElementById('bakery-cps'),
                    baked: document.getElementById('bakery-baked'),
                    actionButton: document.getElementById('bakery-action-button'),
                    canvas: document.getElementById('cookie-canvas'),
                    rainContainer: document.getElementById('cookie-rain-container'),
                    glazeColorButton: document.getElementById('glaze-color-button'),
                    sprinkleColorButton: document.getElementById('sprinkle-color-button'), // NEW
                    donutBaseColorButton: document.getElementById('donut-base-color-button'), // NEW
                    zoomSlider: document.getElementById('glazery-zoom-slider'),
                    // NEW: Second row stats
                    donutBalance: document.getElementById('player-donut-balance'),
                    totalGlazeTime: document.getElementById('player-total-glaze-time'),
                    percentMined: document.getElementById('player-percent-mined'),
                },
                musicToggleButton: document.getElementById('music-toggle-button'),
                sfxToggleButton: document.getElementById('sfx-toggle-button'),
                darkModeToggleButton: document.getElementById('dark-mode-toggle-button'),
                // NEW
                infoButton: document.getElementById('info-button'),
                infoModal: document.getElementById('info-modal'),
                infoModalOverlay: document.getElementById('info-modal-overlay'),
                infoModalClose: document.getElementById('info-modal-close'),
                // NEW: Modal info elements
                modalInfo: {
                    totalSupply: document.getElementById('modal-total-supply'),
                    percentMined: document.getElementById('modal-percent-mined'),
                    nextHalving: document.getElementById('modal-next-halving'),
                    totalMiners: document.getElementById('modal-total-miners'),
                }
            };

            // ===============================================================
            // HELPER FUNCTIONS
            // ===============================================================

            const format = (num) => Math.floor(num).toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, '$1,');
            const formatDecimal = (num) => num.toFixed(2);
            
            const formatGlazeTime = (ms) => {
                if (ms === null || ms < 0) {
                    return '00:00:00';
                }
                const totalSeconds = Math.floor(ms / 1000);
                const hours = Math.floor(totalSeconds / 3600);
                const minutes = Math.floor((totalSeconds % 3600) / 60);
                const seconds = totalSeconds % 60;
                
                return [hours, minutes, seconds]
                    .map(v => v.toString().padStart(2, '0'))
                    .join(':');
            };

            // ===============================================================
            // AUDIO SETUP (Tone.js)
            // ===============================================================
            let kick, hiHat, bass, melody;
            let kickSequence, hiHatSequence, bassSequence, melodySequence;
            let isMusicPlaying = false;
            let isAudioInitialized = false;

            let purchaseSound, cuteClickSound;

            function initAudio() {
                if (isAudioInitialized) return;

                Tone.Transport.bpm.value = 140;
                Tone.Transport.swing = 0.2;
                Tone.Transport.swingSubdivision = '8n';
                const limiter = new Tone.Limiter(-6).toDestination();

                // 1. KICK DRUM
                kick = new Tone.MembraneSynth({
                    pitchDecay: 0.01,
                    octaves: 6,
                    oscillator: { type: 'sine' },
                    envelope: { attack: 0.001, decay: 0.3, sustain: 0.01, release: 0.2 }
                }).connect(limiter);
                
                const kickPattern = ['C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null];
                
                kickSequence = new Tone.Sequence((time, note) => {
                    if (note) kick.triggerAttackRelease(note, '8n', time);
                }, kickPattern, '8n');
                kickSequence.loop = true;

                // 2. HI-HAT
                hiHat = new Tone.NoiseSynth({
                    noise: { type: 'white' },
                    envelope: { attack: 0.001, decay: 0.05, sustain: 0, release: 0.05 }
                }).connect(limiter);

                const hiHatPattern = [null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'GC5', null];

                hiHatSequence = new Tone.Sequence((time, note) => {
                    if (note) hiHat.triggerAttackRelease('8n', time);
                }, hiHatPattern, '8n');
                hiHatSequence.loop = true;

                // 3. BASS LINE
                bass = new Tone.MonoSynth({
                    oscillator: { type: 'sawtooth' },
                    filter: { Q: 2, type: 'lowpass', cutoff: 400 },
                    envelope: { attack: 0.01, decay: 0.2, sustain: 0.3, release: 0.5 }
                }).connect(limiter);

                const bassPattern = ['C2', null, 'G2', null, 'C2', null, 'G2', null, 'C2', null, 'G2', null, 'C2', null, 'G2', null, 'C2', null, 'G2', null, 'C2', null, 'G2', null, 'C2', null, 'G2', null, 'C2', null, 'G2', null, 'G#1', null, 'D#2', null, 'G#1', null, 'D#2', null, 'G#1', null, 'D#2', null, 'G#1', null, 'D#2', null, 'G#1', null, 'D#2', null, 'G#1', null, 'D#2', null, 'G#1', null, 'D#2', null, 'G#1', null, 'D#2', null, 'F1', null, 'C2', null, 'F1', null, 'C2', null, 'F1', null, 'C2', null, 'F1', null, 'C2', null, 'F1', null, 'C2', null, 'F1', null, 'C2', null, 'F1', null, 'C2', null, 'F1', null, 'C2', null, 'G1', null, 'D2', null, 'G1', null, 'D2', null, 'G1', null, 'D2', null, 'G1', null, 'D2', null, 'G1', null, 'D2', null, 'G1', null, 'D2', null, 'G1', null, 'D2', null, 'G1', null, 'D2', 'D2'];

                bassSequence = new Tone.Sequence((time, note) => {
                    if (note) bass.triggerAttackRelease(note, '8n', time);
                }, bassPattern, '8n');
                bassSequence.loop = true;

                // 4. MELODY
                melody = new Tone.FMSynth({
                    harmonicity: 3,
                    modulationIndex: 10,
                    oscillator: { type: 'sine' },
                    envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.5 }
                }).connect(limiter);

                const melodyPattern = ['G4', 'A#4', 'C5', null, 'G4', 'D#4', null, null, 'G4', 'A#4', 'C5', null, 'D#5', 'C5', 'A#4', null, 'G4', 'A#4', 'C5', null, 'G4', 'D#4', null, null, 'G4', 'A#4', 'G4', 'D#4', 'C4', null, null, null, 'G#4', 'C5', 'D#5', null, 'C5', 'G#4', null, null, 'G#4', 'C5', 'D#5', null, 'F5', 'D#5', 'C5', null, 'G#4', 'C5', 'D#5', null, 'C5', 'G#4', null, null, 'C5', 'A#4', 'G#4', 'F4', 'D#4', null, null, null, 'F4', 'G#4', 'C5', null, 'G#4', 'F4', null, null, 'F4', 'G#4', 'C5', null, 'D#5', 'C5', 'G#4', null, 'F4', 'G#4', 'C5', null, 'G#4', 'F4', null, null, 'F4', 'G#4', 'F4', 'D#4', 'C4', null, null, null, 'G4', 'B4', 'D5', null, 'D5', 'B4', 'G4', null, 'G4', 'B4', 'D5', 'F5', 'D5', 'B4', 'G4', null, 'A#4', null, 'B4', null, 'C5', null, 'B4', 'A#4', 'G4', 'F4', 'D#4', 'D4', 'C4', null, null, null];
                
                melodySequence = new Tone.Sequence((time, note) => {
                    if (note) melody.triggerAttackRelease(note, '8n', time);
                }, melodyPattern, '8n');
                melodySequence.loop = true;

                // Initialize SFX
                cuteClickSound = new Tone.FMSynth({
                    oscillator: { type: 'sine' },
                    envelope: { attack: 0.001, decay: 0.05, sustain: 0, release: 0.1 },
                    harmonicity: 0.5,
                    modulationIndex: 2
                }).connect(limiter);
                
                purchaseSound = new Tone.Synth({
                    oscillator: { type: 'triangle' },
                    envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.2 }
                }).connect(limiter);

                isAudioInitialized = true;
            }

            function playSoundEffect(sound, ...args) {
                if (state.ui.isSfxMuted) return;

                if (Tone.context.state !== 'running') {
                    Tone.start();
                }
                
                if (!isAudioInitialized) {
                    initAudio();
                }
                
                if (!state.ui.isSfxMuted) {
                    if (sound === 'crunch') {
                        cuteClickSound.triggerAttackRelease('C6', '32n', Tone.now());
                    }
                    if (sound === 'purchase') {
                        purchaseSound.triggerAttackRelease('C5', '16n', Tone.now());
                        purchaseSound.triggerAttackRelease('E5', '16n', Tone.now() + 0.05);
                        purchaseSound.triggerAttackRelease('G5', '16n', Tone.now() + 0.1);
                    }
                }
            }
            
            function toggleSfx() {
                state.ui.isSfxMuted = !state.ui.isSfxMuted;
                dom.sfxToggleButton.textContent = state.ui.isSfxMuted ? 'üîá' : 'üîä';

                if (!state.ui.isSfxMuted) {
                    playSoundEffect('crunch');
                }
            }

            function toggleMusic() {
                if (Tone.context.state !== 'running') {
                    Tone.start();
                }

                if (!isAudioInitialized) {
                    initAudio();
                }

                if (isMusicPlaying) {
                    // NEW: Only stop the Transport. This stops all events
                    // and resets the Transport time to 0.
                    Tone.Transport.stop();
                    
                    /* REMOVED: Explicitly stopping sequences caused errors 
                       and issues restarting.
                    if (kickSequence) kickSequence.stop();
                    if (hiHatSequence) hiHatSequence.stop();
                    if (bassSequence) bassSequence.stop();
                    if (melodySequence) melodySequence.stop();
                    */
                    
                    dom.musicToggleButton.textContent = 'üîá';
                } else {
                    Tone.Transport.start();
                    
                    // NEW: Check if sequences are 'stopped' before starting them.
                    // This ensures they start on the first play, and also
                    // restart correctly after being stopped by the Transport.
                    if (kickSequence && kickSequence.state === 'stopped') {
                         kickSequence.start(0);
                    }
                    if (hiHatSequence && hiHatSequence.state === 'stopped') {
                         hiHatSequence.start(0);
                    }
                    if (bassSequence && bassSequence.state === 'stopped') {
                         bassSequence.start(0);
                    }
                    if (melodySequence && melodySequence.state === 'stopped') {
                         melodySequence.start(0);
                    }

                    dom.musicToggleButton.textContent = 'üéµ';
                }
                isMusicPlaying = !isMusicPlaying;
            }

            // ===============================================================
            // DARK MODE TOGGLE (NEW)
            // ===============================================================
            function toggleDarkMode() {
                state.ui.isDarkMode = !state.ui.isDarkMode;
                const body = document.body; // Changed from appShell to body
                if (state.ui.isDarkMode) {
                    body.classList.add('dark');
                    dom.darkModeToggleButton.textContent = '‚òÄÔ∏è';
                } else {
                    body.classList.remove('dark');
                    dom.darkModeToggleButton.textContent = 'üåô';
                }
            }

            // ===============================================================
            // INFO MODAL (NEW)
            // ===============================================================
            function showInfoModal() {
                playSoundEffect('crunch');
                dom.infoModal.classList.remove('hidden');
                dom.infoModalOverlay.classList.remove('hidden');
            }

            function hideInfoModal() {
                // No sound on close, feels better
                // playSoundEffect('crunch'); 
                dom.infoModal.classList.add('hidden');
                dom.infoModalOverlay.classList.add('hidden');
            }

            // ===============================================================
            // 3D GLAZERY SETUP
            // ===============================================================

            let scene, camera, renderer, donutGroup, glazeMaterial, donutMaterial, sprinkleMeshes = []; // MODIFIED: Added donutMaterial, sprinkleMeshes
            let isDragging = false;
            let previousPointerX = 0;
            let previousPointerY = 0;
            let initialPinchDistance = 0;
            let currentCameraZ = 10;
            let isThreeJSInitialized = false; 
            let donutSpinSpeed = 0.005; // NEW: Control variable for spin speed

            const MIN_ZOOM_Z = 3;
            const MAX_ZOOM_Z = 20;

            const glazeColors = [
                0xFFC0CB, // Original Pink
                0xADD8E6, // Light Blue
                0x90EE90, // Light Green
                0xFFD700, // Gold (Yellow)
                0x800080, // Purple
                0xFFF8DC, // Cream
                0xFF0000, // Red
                0x000000  // Black
            ];
            let currentGlazeColorIndex = 0;

            const donutBaseColors = [ // NEW
                0x5C3317, // Original Brown
                0xDEB887, // BurlyWood (Lighter)
                0x3D2B1F, // Dark Brown
                0xF5DEB3, // Wheat
                0xFFC0CB, // Pink (for fun)
                null      // NEW: Wireframe flag
            ];
            let currentDonutBaseColorIndex = 0;

            const sprinkleColorSets = [ // NEW: Sprinkle color sets
                [0xFF0000, 0xFF7F00, 0xFFFF00, 0x00FF00, 0x0000FF, 0x4B0082, 0x9400D3], // Rainbow
                [0xFFFFFF, 0xF0F0F0, 0xE0E0E0], // White/Silver
                [0x000000, 0x333333, 0x666666], // Black/Grey
                [0xFFC0CB, 0xFF9AA2, 0xFFDDE1], // Pink Tones
                [0x87CEEB, 0xADD8E6, 0xB0E0E6], // Blue Tones
                [0xDAA520, 0xB8860B, 0xFFD700]  // Gold Tones
            ];
            let currentSprinkleColorSetIndex = 0;

            function createCrackTexture(size = 1024) {
                const canvas = document.createElement('canvas');
                canvas.width = size;
                canvas.height = size;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, size, size);

                ctx.strokeStyle = '#333333';
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                for (let i = 0; i < 15; i++) {
                    ctx.beginPath();
                    let startX = Math.random() * size;
                    let startY = Math.random() * size;
                    ctx.moveTo(startX, startY);
                    let len = Math.random() * 60 + 30;
                    let currentX = startX;
                    let currentY = startY;
                    for (let j = 0; j < 5; j++) {
                         currentX += (Math.random() - 0.5) * len;
                         currentY += (Math.random() - 0.5) * len;
                         currentX = Math.max(0, Math.min(size, currentX));
                         currentY = Math.max(0, Math.min(size, currentY));
                        ctx.lineTo(currentX, currentY);
                        len *= 0.8;
                    }
                    ctx.stroke();
                }

                return new THREE.CanvasTexture(canvas);
            }

            function createSpeckleTexture(size = 512, color = 'rgba(0,0,0,0.5)') {
                const canvas = document.createElement('canvas');
                canvas.width = size;
                canvas.height = size;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#FFFFFF'; 
                ctx.fillRect(0, 0, size, size);

                for (let i = 0; i < 2000; i++) {
                    const x = Math.random() * size;
                    const y = Math.random() * size;
                    const r = Math.random() * 0.8 + 0.4;
                    const alpha = Math.random() * 0.5 + 0.3;
                    const shade = Math.floor(Math.random() * 40);
                    ctx.fillStyle = `rgba(${shade}, ${shade}, ${shade}, ${alpha})`; 
                    
                    ctx.beginPath();
                    ctx.arc(x, y, r, 0, Math.PI * 2);
                    ctx.fill();
                }

                return new THREE.CanvasTexture(canvas);
            }

            function initThreeJS() {
                if (isThreeJSInitialized) return; 
                
                scene = new THREE.Scene();
                
                const container = dom.glazery.rainContainer;
                if (!container) return;
                const w = container.clientWidth || 300;
                const h = container.clientHeight || 300;

                camera = new THREE.PerspectiveCamera(75, w / h, 0.1, 1000);
                camera.position.z = currentCameraZ;

                if (!dom.glazery.canvas) return;
                renderer = new THREE.WebGLRenderer({ 
                    canvas: dom.glazery.canvas,
                    alpha: true
                });
                renderer.setSize(w, h);
                renderer.setPixelRatio(window.devicePixelRatio);

                const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
                scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7); 
                directionalLight.position.set(5, 5, 5);
                scene.add(directionalLight);

                donutGroup = new THREE.Group();
                
                // Donut Base
                const donutGeometry = new THREE.TorusGeometry(2.8, 1.3, 32, 100);

                const crackTexture = createCrackTexture(1024);
                crackTexture.wrapS = crackTexture.wrapT = THREE.RepeatWrapping;
                crackTexture.repeat.set(1, 1);
                
                const speckleTexture = createSpeckleTexture(512);
                speckleTexture.wrapS = speckleTexture.wrapT = THREE.RepeatWrapping;
                speckleTexture.repeat.set(3, 3);

                donutMaterial = new THREE.MeshStandardMaterial({ // MODIFIED: Assigned to global var
                    color: donutBaseColors[currentDonutBaseColorIndex], // MODIFIED: Use color from array
                    roughness: 0.8,
                    metalness: 0.05,
                    map: speckleTexture,
                    bumpMap: crackTexture,
                    bumpScale: 0.08
                });
                const donutBase = new THREE.Mesh(donutGeometry, donutMaterial);
                donutGroup.add(donutBase);

                // Glaze Layer
                const glazeRadius = 2.75; 
                const glazeTubeRadius = 1.35; 
                const radialSegments = 32; 
                const tubularSegments = 100;

                const glazeGeometry = new THREE.TorusGeometry(
                    glazeRadius,
                    glazeTubeRadius,
                    radialSegments,
                    tubularSegments
                );
                
                const positionAttribute = glazeGeometry.attributes.position;
                const tempVector = new THREE.Vector3();
                const irregularityFactor = 0.15; 
                const randomOffsets = new Array(tubularSegments).fill(0).map(() => Math.random() * irregularityFactor * 2 - irregularityFactor);

                for (let i = 0; i < positionAttribute.count; i++) {
                    tempVector.fromBufferAttribute(positionAttribute, i);

                    const x = tempVector.x;
                    const y = tempVector.y;
                    const z = tempVector.z;
                    const r = Math.sqrt(x * x + y * y);
                    const angleAroundDonut = Math.atan2(y, x); 
                    const distFromGlazeMainRadius = Math.abs(r - glazeRadius);
                    const isOuterEdge = distFromGlazeMainRadius < (glazeTubeRadius * 0.4) && r > glazeRadius; 
                    const isBottomHalf = z < -0.4 * glazeTubeRadius; 
                    const isInnerEdge = distFromGlazeMainRadius < (glazeTubeRadius * 0.4) && r < glazeRadius;

                    if (isOuterEdge && isBottomHalf) {
                        const segmentIndex = Math.floor((angleAroundDonut / (2 * Math.PI)) * tubularSegments + tubularSegments) % tubularSegments;
                        const scallopMagnitude = 0.1 + (randomOffsets[segmentIndex] * 0.8 + 0.5) * 0.1; 
                        const currentRadius = Math.sqrt(tempVector.x * tempVector.x + tempVector.y * tempVector.y);
                        const normalizedX = tempVector.x / currentRadius;
                        const normalizedY = tempVector.y / currentRadius;

                        tempVector.x += normalizedX * scallopMagnitude;
                        tempVector.y += normalizedY * scallopMagnitude;
                        tempVector.z += scallopMagnitude * 0.5; 
                        positionAttribute.setXYZ(i, tempVector.x, tempVector.y, tempVector.z);
                    } else if (isInnerEdge) {
                        if (tempVector.z < -0.1) { 
                           tempVector.z = Math.min(tempVector.z + 0.1, 0); 
                        }
                        positionAttribute.setXYZ(i, tempVector.x, tempVector.y, tempVector.z);
                    }
                }
                glazeGeometry.attributes.position.needsUpdate = true;
                glazeGeometry.computeVertexNormals(); 

                glazeMaterial = new THREE.MeshStandardMaterial({
                    color: glazeColors[currentGlazeColorIndex],
                    roughness: 0.2,  
                    metalness: 0.1,  
                    transparent: true,
                    opacity: 0.85    
                });
                const glaze = new THREE.Mesh(glazeGeometry, glazeMaterial);
                glaze.position.z = 0.05; 
                donutGroup.add(glaze);

                // Sprinkles (Initial creation)
                createSprinkles(); // Refactored to a separate function
                
                scene.add(donutGroup);

                // Add pointer listeners for Glazery
                dom.glazery.canvas.addEventListener('pointerdown', onPointerDown);
                dom.glazery.canvas.addEventListener('pointermove', onPointerMove);
                dom.glazery.canvas.addEventListener('pointerup', onPointerUp);
                dom.glazery.canvas.addEventListener('pointerleave', onPointerUp);
                dom.glazery.canvas.addEventListener('wheel', onMouseWheel, { passive: false });
                
                // Setup zoom slider
                dom.glazery.zoomSlider.min = MIN_ZOOM_Z;
                dom.glazery.zoomSlider.max = MAX_ZOOM_Z;
                dom.glazery.zoomSlider.value = currentCameraZ;
                dom.glazery.zoomSlider.step = 0.1;

                isThreeJSInitialized = true; 
            }

            function createSprinkles() {
                // Remove existing sprinkles if any
                sprinkleMeshes.forEach(sprinkle => donutGroup.remove(sprinkle));
                sprinkleMeshes = [];

                const currentColors = sprinkleColorSets[currentSprinkleColorSetIndex];

                const sprinkleShape = new THREE.CylinderGeometry(0.06, 0.06, 0.4, 8); 
                const numSprinkles = 800; 
                const R_sprinkle = 2.8; 
                const r_sprinkle = 1.3 * 0.9; 

                for (let i = 0; i < numSprinkles; i++) {
                    const color = currentColors[Math.floor(Math.random() * currentColors.length)];
                    const sprinkleMaterial = new THREE.MeshStandardMaterial({ color: color });
                    const sprinkle = new THREE.Mesh(sprinkleShape, sprinkleMaterial);
                    const u = Math.random() * 2 * Math.PI; 
                    const v = Math.random() * 2 * Math.PI; 
                    
                    sprinkle.position.x = (R_sprinkle + r_sprinkle * Math.cos(u)) * Math.cos(v);
                    sprinkle.position.y = (R_sprinkle + r_sprinkle * Math.cos(u)) * Math.sin(v);
                    sprinkle.position.z = r_sprinkle * Math.sin(u);

                    if (sprinkle.position.z < -0.2 * 1.3) { 
                        continue; 
                    }

                    const centerOfTubeCrossSection = new THREE.Vector3(R_sprinkle * Math.cos(v), R_sprinkle * Math.sin(v), 0);
                    const normal = new THREE.Vector3().subVectors(sprinkle.position, centerOfTubeCrossSection).normalize();
                    sprinkle.position.addScaledVector(normal, 0.12); 
                    sprinkle.lookAt(new THREE.Vector3().addVectors(sprinkle.position, normal));
                    sprinkle.rotateX(Math.PI / 2); 
                    sprinkle.rotation.z += Math.random() * Math.PI; 
                    donutGroup.add(sprinkle);
                    sprinkleMeshes.push(sprinkle); // Store reference
                }
            }


            // ===============================================================
            // UNIVERSAL 3D CONTROLS & ANIMATION
            // ===============================================================

            function onResize() {
                // Resize Glazery Canvas
                if (renderer && camera && dom.glazery.rainContainer) {
                    const container = dom.glazery.rainContainer;
                    const w = container.clientWidth;
                    const h = container.clientHeight;
                    if (w > 0 && h > 0) {
                        camera.aspect = w / h;
                        camera.updateProjectionMatrix();
                        renderer.setSize(w, h);
                    }
                }
            }
            window.addEventListener('resize', onResize);

            function animate() {
                requestAnimationFrame(animate);
                
                // Render Glazery if active - REMOVED activeView check
                if (donutGroup && renderer) {
                    // MODIFIED: Always spin based on donutSpinSpeed, remove isDragging check
                    donutGroup.rotation.y += donutSpinSpeed; 
                    
                    // NEW: Add damping/friction to slow the spin down
                    if (donutSpinSpeed > 0.005) {
                        donutSpinSpeed *= 0.95; // Apply friction
                        // If it gets very close to the base speed, clamp it
                        if (donutSpinSpeed < 0.006) {
                            donutSpinSpeed = 0.005;
                        }
                    }
                    
                    renderer.render(scene, camera);
                }
            }

            // --- Glazery (Donut) Pointer Events ---
            let pointers = [];

            function getPinchDistance(e) {
                if (e.touches && e.touches.length === 2) {
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    return Math.sqrt(dx * dx + dy * dy);
                }
                return 0;
            }

            function onPointerDown(e) {
                pointers.push(e);
                if (pointers.length === 1) {
                    isDragging = true;
                    previousPointerX = e.clientX;
                    previousPointerY = e.clientY;
                }
                // Removed else if for two fingers to simplify interaction to only rotation/zoom on the donut
                dom.glazery.canvas.setPointerCapture(e.pointerId);
            }

            function onPointerMove(e) {
                const index = pointers.findIndex(p => p.pointerId === e.pointerId);
                if (index > -1) {
                    pointers[index] = e;
                }

                if (pointers.length === 2 && initialPinchDistance > 0) {
                    const currentPinchDistance = getPinchDistance(e);
                    if (currentPinchDistance === 0) return;
                    
                    const zoomFactor = initialPinchDistance / currentPinchDistance;
                    let newZ = currentCameraZ * zoomFactor;
                    
                    newZ = Math.max(MIN_ZOOM_Z, Math.min(MAX_ZOOM_Z, newZ));
                    camera.position.z = newZ;
                    camera.updateProjectionMatrix();
                    dom.glazery.zoomSlider.value = newZ;

                    initialPinchDistance = currentPinchDistance;
                    currentCameraZ = newZ;

                }
                // MODIFIED: Allow rotation with one finger even if another is still down (pinch ended)
                if (isDragging && pointers.length === 1) { 
                    const deltaX = e.clientX - previousPointerX;
                    const deltaY = e.clientY - previousPointerY;
                    
                    donutGroup.rotation.y += deltaX * 0.01;
                    donutGroup.rotation.x += deltaY * 0.01;
                    
                    previousPointerX = e.clientX;
                    previousPointerY = e.clientY;
                }
            }

            function onPointerUp(e) {
                pointers = pointers.filter(p => p.pointerId !== e.pointerId);
                dom.glazery.canvas.releasePointerCapture(e.pointerId);

                // No longer perform action on up, just stop dragging
                if (isDragging && pointers.length === 0) {
                    isDragging = false;
                }

                if (pointers.length < 2) {
                    initialPinchDistance = 0;
                }
            }

            function onMouseWheel(e) {
                e.preventDefault();
                let newZ = currentCameraZ + e.deltaY * 0.02;
                newZ = Math.max(MIN_ZOOM_Z, Math.min(MAX_ZOOM_Z, newZ));
                camera.position.z = newZ;
                camera.updateProjectionMatrix();
                dom.glazery.zoomSlider.value = newZ;
                currentCameraZ = newZ;
            }

            function changeGlazeColor() {
                if (glazeMaterial) {
                    currentGlazeColorIndex = (currentGlazeColorIndex + 1) % glazeColors.length;
                    glazeMaterial.color.set(glazeColors[currentGlazeColorIndex]);
                }
            }

            function changeDonutBaseColor() { // NEW
                if (donutMaterial) {
                    currentDonutBaseColorIndex = (currentDonutBaseColorIndex + 1) % donutBaseColors.length;
                    const newColorOrMode = donutBaseColors[currentDonutBaseColorIndex];

                    if (newColorOrMode === null) {
                        // Activate wireframe mode
                        donutMaterial.wireframe = true;
                        // Set wireframe color to something visible (e.g., light cream, matches dark mode text)
                        donutMaterial.color.set(0xF5E6C1); 
                    } else {
                        // Activate solid mode
                        donutMaterial.wireframe = false;
                        donutMaterial.color.set(newColorOrMode);
                    }
                }
            }

            function changeSprinkleColor() { // NEW
                currentSprinkleColorSetIndex = (currentSprinkleColorSetIndex + 1) % sprinkleColorSets.length;
                createSprinkles(); // Recreate sprinkles with new color set
            }


            // ===============================================================
            // RENDER/UPDATE FUNCTIONS
            // ===============================================================

            const updateUI = () => {
                // NEW: Calculate percentMined globally for both views
                const { totalDonutSupply, totalCookiesCreated, nextHalvingAt, totalMiners } = state.global;
                const percentMined = totalDonutSupply > 0 ? (totalCookiesCreated / totalDonutSupply) * 100 : 0;

                // Update Glazery View (always, since it's the main view)
                
                // NEW: Update second row of stats
                dom.glazery.donutBalance.textContent = 'üç© ' + format(state.player.cookies);
                dom.glazery.totalGlazeTime.textContent = formatGlazeTime(state.player.totalGlazeTimeMs);
                dom.glazery.percentMined.textContent = formatDecimal(percentMined);

                // --- Update first row of stats ---
                const bakeryCps = state.player.isBakerKing ? state.global.emissionRate : 0; 
                dom.glazery.cps.textContent = formatDecimal(bakeryCps);
                
                if (state.player.isBakerKing && state.player.glazeStartTime) {
                    const elapsedMs = Date.now() - state.player.glazeStartTime;
                    dom.glazery.baked.textContent = formatGlazeTime(elapsedMs);
                } else {
                    dom.glazery.baked.textContent = '00:00:00';
                }
                
                const claimableBakery = Math.floor(state.player.claimableBakeryCookies);
                if (state.player.isBakerKing) {
                    dom.glazery.kingStatus.textContent = 'You';
                    dom.glazery.actionButton.textContent = `Bake ${format(claimableBakery)}`;
                    dom.glazery.actionButton.disabled = claimableBakery < 1;
                } else {
                    dom.glazery.kingStatus.textContent = 'None';
                    dom.glazery.actionButton.textContent = 'Glaze';
                    dom.glazery.actionButton.disabled = false;
                }
                
                // NEW: Calculate halving time (used in two places)
                const blocksRemaining = nextHalvingAt - totalCookiesCreated;
                const secondsRemaining = Math.max(0, Math.floor(blocksRemaining * (GAME_TICK_MS / 100))); 
                const hours = Math.floor(secondsRemaining / 3600);
                const minutes = Math.floor((secondsRemaining % 3600) / 60);
                const seconds = secondsRemaining % 60;
                const halvingTimeText = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;

                // Update About Page Stats - REMOVED this entire block
                
                // NEW: Update Modal Stats (always, so it's fresh when opened)
                if (dom.modalInfo.totalSupply) { // Check if elements exist
                    dom.modalInfo.totalSupply.textContent = `üç© ${format(totalDonutSupply)}`;
                    dom.modalInfo.percentMined.textContent = `${formatDecimal(percentMined)}%`;
                    dom.modalInfo.nextHalving.textContent = halvingTimeText;
                    dom.modalInfo.totalMiners.textContent = `üë§ ${format(totalMiners)}`;
                }
            };
            
            // REMOVED showView function

            // ===============================================================
            // GAME ACTIONS (NEW SECTION)
            // ===============================================================

            const handleMinerAction = () => {
                donutSpinSpeed = 0.5; // NEW: Set spin speed to high!

                if (state.player.isBakerKing) {
                    // Claim "Bake"
                    const claimable = Math.floor(state.player.claimableBakeryCookies);
                    if (claimable > 0) {
                        playSoundEffect('purchase');
                        state.player.cookies += claimable;
                        state.player.totalBakedCookies += claimable;
                        state.player.claimableBakeryCookies = 0;
                        console.log(`Claimed ${claimable} cookies.`);
                    }
                } else {
                    // Become "Glazer" (King)
                    playSoundEffect('purchase');
                    state.player.isBakerKing = true;
                    state.player.glazeStartTime = Date.now();
                    console.log("You are now the King Glazer!");
                }
                
                updateUI();
            };

            // ===============================================================
            // GAME LOOP
            // ===============================================================
            
            const GAME_TICK_MS = 100;

            const gameLoop = () => {
                // MOCK: Increment total mined cookies for countdown demo
                state.global.totalCookiesCreated += state.global.emissionRate * (GAME_TICK_MS / 1000);
                
                // MOCK: Increment claimable cookies if king
                if (state.player.isBakerKing) {
                    const bakeryCps = state.global.emissionRate;
                    state.player.claimableBakeryCookies += bakeryCps * (GAME_TICK_MS / 1000);
                    state.player.totalGlazeTimeMs += GAME_TICK_MS; // NEW: Increment total glaze time
                }
                
                updateUI();
            };

            // ===============================================================
            // INITIALIZATION
            // ===============================================================
            
            // REMOVED nav listeners
            // NOTE: This will be replaced by handleMinerActionWithContract after contract integration loads
            dom.glazery.actionButton.onclick = handleMinerAction;
            dom.musicToggleButton.onclick = toggleMusic;
            dom.sfxToggleButton.onclick = toggleSfx;
            dom.darkModeToggleButton.onclick = () => {
                playSoundEffect('crunch');
                toggleDarkMode();
            };
            dom.glazery.glazeColorButton.onclick = () => {
                playSoundEffect('crunch');
                changeGlazeColor();
            };
            dom.glazery.sprinkleColorButton.onclick = () => { // NEW
                playSoundEffect('crunch');
                changeSprinkleColor();
            };
            dom.glazery.donutBaseColorButton.onclick = () => { // NEW
                playSoundEffect('crunch');
                changeDonutBaseColor();
            };

            // NEW MODAL LISTENERS
            dom.infoButton.onclick = showInfoModal;
            dom.infoModalClose.onclick = hideInfoModal;
            dom.infoModalOverlay.onclick = hideInfoModal;

            dom.glazery.zoomSlider.oninput = () => {
                if (!isThreeJSInitialized) return;
                const newZ = parseFloat(dom.glazery.zoomSlider.value);
                camera.position.z = newZ;
                camera.updateProjectionMatrix();
                currentCameraZ = newZ;
            };

            // REMOVED showView('glazery');
            setInterval(gameLoop, GAME_TICK_MS);
            
            if (!isThreeJSInitialized) {
                setTimeout(initThreeJS, 0); 
            }
            
            animate();

            // =====================================================================
            // CONTRACT INTEGRATION INITIALIZATION
            // =====================================================================
            
            // Initialize contract integration after game is ready
            if (typeof contractIntegration !== 'undefined' && contractIntegration.initContractIntegration) {
                console.log('[Game] Initializing contract integration...');
                contractIntegration.initContractIntegration();
            } else {
                console.warn('[Game] Contract integration module not found');
            }
        });

        // =============================================================================
        // CONTRACT INTEGRATION MODULE
        // =============================================================================

        // --- CONFIGURATION ---
        // IMPORTANT: This points to your API deployment (not the game URL)
        const API_BASE_URL = 'https://last-game-kappa.vercel.app'; // Your API Vercel deployment
        const GAME_REFRESH_INTERVAL = 10000; // Refresh every 10 seconds

        // --- CONTRACT DATA STATE ---
        let contractData = {
            currentMiner: null,
            price: '0',
            priceInEth: '0',
            epochId: 0,
            currentDps: '0',
            currentDpsFormatted: '0',
            nextDps: '0',
            nextDpsFormatted: '0',
            userDonutBalance: '0',
            userDonutBalanceFormatted: '0',
            userEthBalance: '0',
            userEthBalanceFormatted: '0',
            claimableDonuts: '0',
            claimableDonutsFormatted: '0',
            totalDonutSupply: '0',
            totalDonutSupplyFormatted: '0',
            secondsUntilHalving: 0,
            timeAsMiner: 0,
            userAddress: null
        };

        // --- HELPER FUNCTIONS ---

        // Format numbers for display
        function formatNumber(num) {
            const n = parseFloat(num);
            if (n >= 1000000) return (n / 1000000).toFixed(2) + 'M';
            if (n >= 1000) return (n / 1000).toFixed(2) + 'K';
            return n.toFixed(2);
        }

        // Format time as HH:MM:SS
        function formatTime(seconds) {
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            const s = seconds % 60;
            return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
        }

        // --- FETCH GAME STATE FROM API ---
        async function fetchGameState(userAddress = null) {
            try {
                const url = userAddress 
                    ? `${API_BASE_URL}/api/get-game-state?userAddress=${userAddress}`
                    : `${API_BASE_URL}/api/get-game-state`;
                
                console.log('[Contract] Fetching game state from:', url);
                console.log('[Contract] Current origin:', window.location.origin);
                
                const response = await fetch(url, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    mode: 'cors',
                    credentials: 'omit'
                });
                
                console.log('[Contract] Fetch response status:', response.status);
                console.log('[Contract] Fetch response ok:', response.ok);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                console.log('[Contract] Game state received:', data);
                
                // Update contract data
                contractData = {
                    ...contractData,
                    ...data
                };
                
                return data;
            } catch (error) {
                console.error('[Contract] Error fetching game state:', error);
                console.error('[Contract] Error type:', error.name);
                console.error('[Contract] Error message:', error.message);
                
                // Try to provide more helpful error info
                if (error.message === 'Failed to fetch') {
                    console.error('[Contract] This is likely a CORS or network issue');
                    console.error('[Contract] Check that API is accessible and CORS is configured');
                }
                
                return null;
            }
        }

        // --- GET USER ADDRESS FROM FARCASTER CONTEXT ---
        async function getUserAddress() {
            try {
                console.log('[Contract] Attempting to get user from Farcaster context...');
                
                // Method 1: Check for Farcaster frame context (injected by Farcaster)
                if (window.frameContext && window.frameContext.user) {
                    const fid = window.frameContext.user.fid;
                    console.log('[Contract] User FID from frameContext:', fid);
                    
                    // Get address from Farcaster via API
                    try {
                        const response = await fetch(`https://api.neynar.com/v2/farcaster/user/bulk?fids=${fid}`, {
                            headers: {
                                'api_key': 'NEYNAR_ONCHAIN_KIT' // Public key for basic lookups
                            }
                        });
                        const data = await response.json();
                        if (data.users && data.users[0] && data.users[0].verified_addresses && data.users[0].verified_addresses.eth_addresses) {
                            const address = data.users[0].verified_addresses.eth_addresses[0];
                            console.log('[Contract] User address from Neynar:', address);
                            contractData.userAddress = address;
                            return address;
                        }
                    } catch (e) {
                        console.log('[Contract] Could not fetch address from Neynar:', e.message);
                    }
                }
                
                // Method 2: Try Farcaster SDK as fallback
                console.log('[Contract] Trying Farcaster SDK as fallback...');
                try {
                    const sdkImport = await Promise.race([
                        import('https://esm.sh/@farcaster/miniapp-sdk'),
                        new Promise((_, reject) => setTimeout(() => reject(new Error('SDK timeout')), 3000))
                    ]);
                    
                    const sdk = sdkImport.default;
                    await sdk.actions.ready();
                    
                    const provider = await sdk.wallet.getEthereumProvider();
                    if (provider) {
                        const accounts = await provider.request({ method: 'eth_requestAccounts' });
                        const address = accounts[0];
                        console.log('[Contract] User address from SDK:', address);
                        contractData.userAddress = address;
                        return address;
                    }
                } catch (sdkError) {
                    console.log('[Contract] SDK fallback failed:', sdkError.message);
                }
                
                console.log('[Contract] Could not get user address - continuing without it');
                return null;
                
            } catch (error) {
                console.log('[Contract] Error getting user address:', error.message);
                return null;
            }
        }

        // --- UPDATE UI WITH CONTRACT DATA ---
        function updateUIFromContract() {
            console.log('[Contract] Updating UI with contract data');
            
            // Check if state exists first
            if (typeof state === 'undefined' || !state) {
                console.log('[Contract] Game state not ready yet, skipping UI update');
                return;
            }
            
            // Update global state to reflect contract data
            if (state && state.global) {
                // Map contract data to game state
                state.global.emissionRate = parseFloat(contractData.currentDpsFormatted);
                state.global.totalDonutSupply = parseFloat(contractData.totalDonutSupplyFormatted);
                state.global.totalCookiesCreated = parseFloat(contractData.totalDonutSupplyFormatted); // Simplified
                
                // Update player state
                if (state.player) {
                    state.player.cookies = parseFloat(contractData.userDonutBalanceFormatted);
                    
                    // Check if user is the current miner
                    const userIsMiner = contractData.userAddress && 
                                       contractData.currentMiner && 
                                       contractData.userAddress.toLowerCase() === contractData.currentMiner.toLowerCase();
                    
                    state.player.isBakerKing = userIsMiner;
                    
                    if (userIsMiner) {
                        state.player.claimableBakeryCookies = parseFloat(contractData.claimableDonutsFormatted);
                        state.player.glazeStartTime = Date.now() - (contractData.timeAsMiner * 1000);
                    } else {
                        state.player.claimableBakeryCookies = 0;
                        state.player.glazeStartTime = null;
                    }
                }
            }
            
            // Update modal info if it exists
            if (typeof dom !== 'undefined' && dom.modalInfo) {
                if (dom.modalInfo.totalSupply) {
                    dom.modalInfo.totalSupply.textContent = `üç© ${formatNumber(contractData.totalDonutSupplyFormatted)}`;
                }
                if (dom.modalInfo.nextHalving) {
                    dom.modalInfo.nextHalving.textContent = formatTime(contractData.secondsUntilHalving);
                }
                if (dom.modalInfo.totalMiners) {
                    dom.modalInfo.totalMiners.textContent = `üë§ 1`; // Only one miner at a time
                }
            }
            
            // Trigger UI update
            if (typeof updateUI === 'function') {
                updateUI();
            }
        }

        // --- OPEN TRANSACTION FRAME ---
        function openGlazeFrame() {
            console.log('[Contract] Opening glaze transaction frame');
            
            // The payment-frame.js will handle the transaction
            const frameUrl = `${API_BASE_URL}/api/payment-frame`;
            
            // Open in a new window (Farcaster will handle this appropriately)
            window.open(frameUrl, '_blank');
            
            // Start polling for state changes after frame opens
            setTimeout(() => {
                console.log('[Contract] Starting refresh after frame opened');
                startAutoRefresh();
            }, 2000);
        }

        // --- AUTO REFRESH ---
        let refreshInterval = null;

        function startAutoRefresh() {
            if (refreshInterval) {
                clearInterval(refreshInterval);
            }
            
            refreshInterval = setInterval(async () => {
                console.log('[Contract] Auto-refreshing game state...');
                await fetchGameState(contractData.userAddress);
                updateUIFromContract();
            }, GAME_REFRESH_INTERVAL);
        }

        function stopAutoRefresh() {
            if (refreshInterval) {
                clearInterval(refreshInterval);
                refreshInterval = null;
            }
        }

        // --- INITIALIZATION ---
        async function initContractIntegration() {
            console.log('[Contract] Initializing contract integration...');
            
            try {
                // Get user address (may fail if not in Farcaster)
                const userAddress = await getUserAddress();
                
                // Fetch initial game state (should always work)
                console.log('[Contract] Fetching game state...');
                const gameState = await fetchGameState(userAddress);
                
                if (!gameState) {
                    console.error('[Contract] Failed to fetch game state - will retry');
                    // Try again without user address
                    await fetchGameState(null);
                }
                
                // Update UI
                updateUIFromContract();
                
                // Start auto refresh
                startAutoRefresh();
                
                console.log('[Contract] Contract integration initialized successfully');
            } catch (error) {
                console.error('[Contract] Error during initialization:', error);
                console.log('[Contract] Will continue with limited functionality');
                
                // Try to at least fetch game state without user
                try {
                    await fetchGameState(null);
                    updateUIFromContract();
                    startAutoRefresh();
                } catch (e) {
                    console.error('[Contract] Critical error - cannot fetch game state:', e);
                }
            }
        }

        // --- OVERRIDE GLAZE BUTTON HANDLER ---
        // This replaces the mock handleMinerAction with real contract interaction
        const originalHandleMinerAction = typeof handleMinerAction !== 'undefined' ? handleMinerAction : null;

        function handleMinerActionWithContract() {
            console.log('[Contract] Glaze button clicked');
            
            // Spin the donut!
            if (typeof donutSpinSpeed !== 'undefined') {
                donutSpinSpeed = 0.5;
            }
            
            // Check if user is current miner
            const userIsMiner = contractData.userAddress && 
                               contractData.currentMiner && 
                               contractData.userAddress.toLowerCase() === contractData.currentMiner.toLowerCase();
            
            if (userIsMiner) {
                // User is miner, but rewards are auto-claimed when someone else takes over
                alert('You are the current miner! Your rewards will be claimed automatically when someone else takes over.');
            } else {
                // User wants to become miner - open transaction frame
                openGlazeFrame();
            }
        }

        // Replace the glaze button handler
        if (typeof handleMinerAction !== 'undefined') {
            // Save original
            window.originalHandleMinerAction = handleMinerAction;
            // Replace with contract version
            window.handleMinerAction = handleMinerActionWithContract;
            handleMinerAction = handleMinerActionWithContract;
        }

        // --- EXPORT FOR GLOBAL ACCESS ---
        window.contractIntegration = {
            fetchGameState,
            getUserAddress,
            updateUIFromContract,
            openGlazeFrame,
            startAutoRefresh,
            stopAutoRefresh,
            initContractIntegration,
            contractData,
            formatNumber,
            formatTime
        };

        console.log('[Contract] Contract integration module loaded. Call contractIntegration.initContractIntegration() to start.');
    </script>
</body>
</html>
