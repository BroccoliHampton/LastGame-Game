<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Donut Miner „ÉÑ</title> <!-- Renamed Title --><script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Include Tone.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <!-- REMOVED: Chart.js script --><style>
        /* =============================================================== */
        /* KISSAKI/TAMAGOTCHI AESTHETIC STYLING                            */
        /* =============================================================== */

        /* Custom Font - Nunito is a good match for the cute, rounded look */
        @import url('https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700;800;900&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Comic+Neue:wght@400;700&display=swap'); /* Changed to Comic Neue */
        @import url('https://fonts.googleapis.com/css2?family=Luckiest+Guy&display=swap'); /* NEW: Added Luckiest Guy font */
        
        /* This is the "browser" background, outside the phone */
        body {
            font-family: 'Nunito', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            overscroll-behavior: none; /* Prevents "pull-to-refresh" */
            
            /* Dark gray background for the page, to make the "phone" pop */
            background-color: #333;
            color: #333333; /* Dark gray for general text */

            /* Center the phone frame */
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 2rem;
        }

        /* This is the new "phone frame" class */
        #app-shell {
            /* Tamagotchi Sprinkles Background */
            background-color: #FFC0CB; /* Soft Pink */
            background-image: url("data:image/svg+xml,%3Csvg width='20' height='20' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='%23f9d4d8' fill-opacity='0.4'%3E%3Cpath d='M10 0L0 10l10 10 10-10z'/%3E%3Cpath d='M0 10L10 20l10-10L10 0z'/%3E%3C/g%3E%3C/svg%3E"); /* Light pink zig-zag pattern */
            /* Add custom sprinkles for more visual pop */
            background-image: url("data:image/svg+xml,%3Csvg width='100' height='100' viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'%3E%3Cg opacity='0.7'%3E%3Crect x='10' y='10' width='3' height='10' fill='%23FFD700' transform='rotate(25 11.5 15)' /%3E%3Crect x='60' y='30' width='3' height='10' fill='%23FF69B4' transform='rotate(140 61.5 35)' /%3E%3Crect x='30' y='70' width='3' height='10' fill='%2390EE90' transform='rotate(70 31.5 75)' /%3E%3Crect x='80' y='85' width='3' height='10' fill='%2387CEEB' transform='rotate(210 81.5 90)' /%3E%3Crect x='5' y='45' width='3' height='10' fill='%23FFD700' transform='rotate(100 6.5 50)' /%3E%3Crect x='90' y='5' width='3' height='10' fill='%23FF69B4' transform='rotate(300 91.5 10)' /%3E%3C/g%3E%3C/svg%3E"), 
                            linear-gradient(135deg, #FFC0CB 0%, #FFDDE1 100%); /* Soft Pink base */
            background-size: 200px 200px, cover; /* Adjust size for sprinkles, cover for gradient */
            background-blend-mode: overlay, normal;
            background-attachment: fixed;
        }
        
        /* Custom Colors inspired by Tamagotchi */
        /* Changed to pale butter yellow */
        .bg-tamagotchi-bg-light { background-color: #FFFACD; } 
        .text-tamagotchi-dark { color: #333333; } /* General dark text */
        .text-tamagotchi-pink-dark { color: #E75480; } /* Stronger, cuter pink for accents/headings */
        .text-tamagotchi-pink-light { color: #FF9AA2; } /* Lighter pink for accents */
        
        /* Button colors */
        .bg-tamagotchi-button-pink { 
            background: linear-gradient(to bottom, #FFDDE1, #E75480); /* Puffy pink gradient */
            color: white;
            font-weight: 800;
            border: 2px solid #C04A70; /* Darker border for depth */
        }
        .bg-tamagotchi-button-teal { 
            background: linear-gradient(to bottom, #B3F0E6, #66CCBF); /* Teal gradient */
            color: white;
            font-weight: 800;
            border: 2px solid #50A89C; /* Darker border for depth */
        }
        .bg-tamagotchi-button-pink:active, .bg-tamagotchi-button-teal:active {
            transform: translateY(1px); /* Simple press effect */
            box-shadow: none;
        }

        /* Border/Card colors */
        .border-tamagotchi-subtle { border-color: #E0E0E0; } /* Light gray border */
        /* Changed to pale butter yellow */
        .bg-tamagotchi-card { 
            background-color: #FFFACD; /* Pale Butter Yellow for cards */
            border: 2px solid #E0E0E0; /* Subtle border */
        }
        .border-tamagotchi-accent-pink { border-color: #FF9AA2; /* Pink accent border */
        }

        /* General rounding */
        .rounded-tamagotchi-lg { border-radius: 20px; } /* More pronounced rounding for cards/buttons */
        .rounded-tamagotchi-md { border-radius: 14px; } /* Medium rounding */
        .rounded-tamagotchi-full { border-radius: 9999px; } /* Full rounding for circular elements */

        /* Shadows (softer, toy-like) */
        .shadow-tamagotchi { box-shadow: 0px 6px 15px rgba(0, 0, 0, 0.1); } /* More pronounced, softer shadow */

        /* Navigation icons - REPLACED with emojis */
        /* @import url("https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200"); */
        
        .nav-icon span {
            font-size: 32px; /* Large emoji */
            color: #A0A0A0; /* Soft gray for inactive icons */
            transition: color 0.2s ease-in-out, transform 0.2s ease-in-out;
        }
        .nav-icon.active span {
            color: #E75480; /* Stronger pink for active icon */
            transform: scale(1.1);
        }

        /* Selected state for store items */
        .store-item.selected {
            background-color: #FEECEF; /* Very light pink background */
            border-color: #E75480; /* Stronger pink border */
            box-shadow: 0px 0px 10px rgba(231, 84, 128, 0.4); /* Soft glow */
        }

        /* Cookie rain animation for Bakery */
        .cookie-rain {
            position: absolute;
            top: -30px;
            font-size: 20px; /* Made smaller for compact view */
            animation: fall 5s linear infinite;
            user-select: none;
            pointer-events: none;
            z-index: 10; 
            text-shadow: 1px 1px 2px rgba(0,0,0,0.2); /* Subtle cookie shadow */
        }

        @keyframes fall {
            0% { transform: translateY(0vh) translateX(0vw) rotate(0deg); opacity: 1; }
            100% { transform: translateY(100vh) translateX(5vw) rotate(360deg); opacity: 0; }
        }

        /* Style for the 3D canvas (both Glazery and Bakery) */
        #cookie-canvas, #bakery-item-canvas {
            width: 100%;
            height: 100%;
            max-width: 400px;
            max-height: 400px;
            cursor: grab;
            touch-action: none;
            position: relative; /* Ensure canvas is positioned above static */
            z-index: 20; /* Higher than static */
        }
        #cookie-canvas:active, #bakery-item-canvas:active {
            cursor: grabbing;
        }

        /* Glaze color button styling */
        #glaze-color-button {
            position: absolute;
            bottom: 10px;
            right: 10px;
            z-index: 30; /* Ensure it's above other elements in the container */
            width: 40px; /* Make it a square */
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            border-radius: 50%; /* Circular button */
            cursor: pointer;
            border: 2px solid #E0E0E0; /* Subtle border */
            background-color: #f0f0f0; /* Default light background */
            box-shadow: 0px 2px 5px rgba(0,0,0,0.2);
            transition: transform 0.1s ease-in-out, background-color 0.2s;
        }
        #glaze-color-button:active {
            transform: translateY(1px);
            box-shadow: none;
        }

        /* =============================================================== */
        /* GLITCHY STATIC TV EFFECT (Pale Butter Yellow Background)      */
        /* =============================================================== */

        .glitch-static {
            position: relative; /* Needed for pseudo-elements */
            overflow: hidden;
            background-color: #FFFACD !important; /* Pale Butter Yellow background - Added !important to override */
        }

        .glitch-static::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                linear-gradient(rgba(240, 230, 200, 0.4) 1px, transparent 1px), /* Softer static lines, matching yellow */
                linear-gradient(90deg, rgba(240, 230, 200, 0.4) 1px, transparent 1px);
            background-size: 4px 4px; /* Slightly larger static pixels */
            animation: static-flicker 0.5s infinite alternate, static-move 3s steps(10) infinite; /* Slower animations */
            opacity: 0.6; /* Softer static */
            pointer-events: none; /* Allows clicks/interactions with elements behind it */
            z-index: 15; /* Below donut, above container bg */
        }

        .glitch-static::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                to bottom,
                transparent 0%,
                rgba(240, 230, 200, 0.2) 50%, /* Softer yellow scanline */
                transparent 100%
            );
            mix-blend-mode: overlay; /* Creates light distortion effect */
            animation: scanline 8s linear infinite; /* Slower scanline */
            opacity: 0.3; /* Slightly more pronounced scanline */
            pointer-events: none;
            z-index: 16; /* Slightly above main static */
        }

        @keyframes static-flicker {
            0% { background-position: 0 0; opacity: 0.6; }
            50% { background-position: 8px 8px; opacity: 0.5; } /* Larger displacement for flicker */
            100% { background-position: 0 0; opacity: 0.7; }
        }

        @keyframes static-move {
            0% { transform: translate(0, 0); }
            100% { transform: translate(0, 100%); }
        }

        @keyframes scanline {
            0% { background-position: 0 0; }
            100% { background-position: 0 100%; }
        }

        /* =============================================================== */
        /* FALLING SNOW (GREY PIXELS) EFFECT                              */
        /* =============================================================== */
        .falling-snow {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 17; /* Above static, below donut */
            overflow: hidden; /* Ensures snowflakes don't go outside */
        }

        .falling-snow::before,
        .falling-snow::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                /* Create many small grey "pixels" */
                radial-gradient(circle at 10% 20%, #A0A0A0 1px, transparent 1px),
                radial-gradient(circle at 70% 80%, #C0C0C0 1px, transparent 1px),
                radial-gradient(circle at 30% 60%, #B0B0B0 1px, transparent 1px),
                radial-gradient(circle at 90% 10%, #E0E0E0 1px, transparent 1px),
                radial-gradient(circle at 50% 40%, #D0D0D0 1px, transparent 1px),
                radial-gradient(circle at 20% 90%, #F0F0F0 1px, transparent 1px),
                radial-gradient(circle at 80% 30%, #A0A0A0 1px, transparent 1px),
                radial-gradient(circle at 40% 70%, #C0C0C0 1px, transparent 1px),
                radial-gradient(circle at 60% 5%, #B0B0B0 1px, transparent 1px),
                radial-gradient(circle at 5% 50%, #E0E0E0 1px, transparent 1px),
                radial-gradient(circle at 95% 45%, #D0D0D0 1px, transparent 1px);
            background-repeat: repeat;
            background-size: 20px 20px; /* Control the density */
            animation: snowfall 10s linear infinite; /* Slower fall */
            opacity: 0.7; /* Make them subtle */
        }

        .falling-snow::after {
            animation-delay: 5s; /* Stagger the animation for more continuous effect */
            background-size: 25px 25px; /* Different size for variety */
            opacity: 0.6;
            filter: blur(0.5px); /* Slight blur for depth */
        }

        @keyframes snowfall {
            0% { transform: translateY(-100%); }
            100% { transform: translateY(100%); }
        }

        /* =============================================================== */
        /* SCROLLING TICKER                                                */
        /* =============================================================== */
        .ticker-wrap {
            width: 100%;
            overflow: hidden;
            background-color: #333; /* Dark background */
            padding: 4px 0; /* Vertical padding */
            border-top: 2px solid #555;
            border-bottom: 2px solid #555;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
            /* margin-bottom: 8px; /* Space between ticker and donut container - adjusted below */
        }
        
        /* Specific margins for top and bottom tickers */
        #top-ticker { margin-bottom: 8px; }
        #bottom-ticker { margin-top: 8px; }


        .ticker-move {
            display: inline-block;
            white-space: nowrap;
            /* padding-right: 100%; */ /* REMOVED - This caused the gap */
            animation: scroll-ticker 20s linear infinite; /* Adjust duration for speed */
            color: #FFFACD; /* Pale Butter Yellow text */
            font-size: 14px;
            font-weight: bold;
            font-family: 'Comic Neue', cursive; /* Match other text */
            text-shadow: 1px 1px 1px rgba(0,0,0,0.5);
        }

        .ticker-move-reverse {
            display: inline-block;
            white-space: nowrap;
            /* padding-left: 100%; */ /* REMOVED - This caused the gap */
            animation: scroll-ticker-reverse 20s linear infinite; /* Adjust duration for speed */
            color: #FFFACD; /* Pale Butter Yellow text */
            font-size: 14px;
            font-weight: bold;
            font-family: 'Comic Neue', cursive; /* Match other text */
            text-shadow: 1px 1px 1px rgba(0,0,0,0.5);
        }

        @keyframes scroll-ticker {
            0% { transform: translateX(0%); } /* Start visible */
            100% { transform: translateX(-50%); } /* Move halfway, showing the duplicated text */
        }

        @keyframes scroll-ticker-reverse {
            0% { transform: translateX(-50%); } /* Start halfway */
            100% { transform: translateX(0%); } /* Move back to start */
        }
        
        /* =============================================================== */
        /* DARK MODE STYLING                                               */
        /* =============================================================== */

        /* Chocolate brown background */
        #app-shell.dark {
            background-color: #5C3317; /* Chocolate Brown */
            background-image: url("data:image/svg+xml,%3Csvg width='20' height='20' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='%236B4A34' fill-opacity='0.4'%3E%3Cpath d='M10 0L0 10l10 10 10-10z'/%3E%3Cpath d='M0 10L10 20l10-10L10 0z'/%3E%3C/g%3E%3C/svg%3E"), 
                            linear-gradient(135deg, #5C3317 0%, #3D2B1F 100%);
        }

        /* Dark cards */
        #app-shell.dark .bg-tamagotchi-card { 
            background-color: #3D2B1F; /* Dark, rich brown */
            border-color: #4A3A2A; /* Darker border */
        }
        
        /* Light text for dark backgrounds */
        #app-shell.dark .text-tamagotchi-dark { color: #F5E6C1; } /* Creamy white text */
        #app-shell.dark .text-gray-500 { color: #A8998A; } /* Lighter, desaturated brown text */
        #app-shell.dark .text-gray-600 { color: #B8A99A; }
        
        /* Pinks can stay, they pop nicely on brown */
        #app-shell.dark .text-tamagotchi-pink-dark { color: #FF9AA2; } /* Lighten the pink a bit */

        /* Glitch background */
        #app-shell.dark .glitch-static {
            background-color: #3D2B1F !important; /* Dark brown */
        }
        #app-shell.dark .glitch-static::before {
            background: 
                linear-gradient(rgba(150, 130, 110, 0.4) 1px, transparent 1px),
                linear-gradient(90deg, rgba(150, 130, 110, 0.4) 1px, transparent 1px);
        }
        #app-shell.dark .glitch-static::after {
            background: linear-gradient(
                to bottom,
                transparent 0%,
                rgba(150, 130, 110, 0.2) 50%,
                transparent 100%
            );
        }
        
        /* Falling snow (grey pixels) will look good on dark */
        /* NEW: Reduce snow opacity in dark mode */
        #app-shell.dark .falling-snow::before {
            opacity: 0.4; /* Was 0.7 */
        }
        #app-shell.dark .falling-snow::after {
            opacity: 0.3; /* Was 0.6 */
        }

        /* Subtle borders */
        #app-shell.dark .border-tamagotchi-subtle { border-color: #4A3A2A; }

        /* Selected item */
        #app-shell.dark .store-item.selected {
            background-color: #4A3A2A; /* Darker selected bg */
            border-color: #E75480; /* Keep pink border */
        }
        
        /* Light-on-dark for nav */
        #app-shell.dark .nav-icon span {
            color: #A8998A; /* Lighter inactive icon */
        }
        #app-shell.dark .nav-icon.active span {
            color: #FF9AA2; /* Lighter active pink */
        }
        
        /* Color cycle button */
        #app-shell.dark #glaze-color-button {
            background-color: #3D2B1F;
            border-color: #4A3A2A;
            color: #F5E6C1; /* Light text */
        }
        
        /* App background for sticky footer */
        #app-shell.dark .bg-tamagotchi-bg-light { 
            background-color: #3D2B1F; /* Dark brown */
        }
        
        /* Ticker text is already light, so it's fine */
        
        /* NEW: Collapsible list icon style */
        #item-list-toggle-icon.collapsed {
            transform: rotate(-90deg);
        }

        /* NEW: Zoom Slider Styling */
        .zoom-slider {
            position: absolute;
            top: 50%;
            right: 12px; /* CHANGED: Was left: 12px */
            transform: translateY(-50%); /* Center vertically */
            width: 20px; /* Track thickness */
            height: 120px; /* Track length */
            -webkit-appearance: none;
            appearance: none;
            writing-mode: vertical-lr; /* Make it vertical */
            direction: ltr; /* CHANGED: Was rtl. Now min-at-top, max-at-bottom */
            background: rgba(0, 0, 0, 0.1);
            border-radius: 10px;
            z-index: 30;
            padding: 0;
            transition: background 0.2s;
        }
        /* Dark mode style for slider */
        #app-shell.dark .zoom-slider {
            background: rgba(255, 255, 255, 0.2);
        }

        /* Thumb styling */
        .zoom-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 26px; /* Touch target */
            height: 26px;
            background: #FFFACD; /* Pale Butter Yellow */
            border-radius: 50%;
            border: 2px solid #E75480; /* Pink border */
            cursor: grab;
        }
        .zoom-slider::-moz-range-thumb {
            width: 26px;
            height: 26px;
            background: #FFFACD;
            border-radius: 50%;
            border: 2px solid #E75480;
            cursor: grab;
        }
        /* Dark mode thumb */
        #app-shell.dark .zoom-slider::-webkit-slider-thumb {
            background: #3D2B1F; /* Dark brown */
            border-color: #FF9AA2; /* Lighter pink */
        }
        #app-shell.dark .zoom-slider::-moz-range-thumb {
            background: #3D2B1F;
            border-color: #FF9AA2;
        }

        /* NEW: Glow effect for boosted mining rate */
        @keyframes pulse-glow-pink {
          0%, 100% {
            text-shadow: 0 0 5px rgba(231, 84, 128, 0.7), 0 0 10px rgba(231, 84, 128, 0.5);
            color: #E75480; /* Strong Pink */
          }
          50% {
            text-shadow: 0 0 10px rgba(255, 154, 162, 1), 0 0 20px rgba(255, 154, 162, 0.7);
            color: #FF9AA2; /* Lighter Pink */
          }
        }
        .text-glow-boosted {
            animation: pulse-glow-pink 1.5s infinite ease-in-out;
            color: #E75480 !important; /* Override default dark text. !important to ensure it applies */
            font-weight: 900; /* Make it extra bold */
        }
        
        /* Dark mode compatibility */
        #app-shell.dark .text-glow-boosted {
            color: #FF9AA2 !important; /* Override default light text */
            /* Animation already uses light/dark pinks, so it should look fine */
        }
        /* END NEW STYLES */

    </style>
</head>
<body class="bg-gray-800 flex items-center justify-center min-h-screen p-4 md:p-8">

    <div id="app-shell" class="w-[390px] h-[844px] max-h-[90vh] bg-tamagotchi-bg-light text-tamagotchi-dark rounded-[40px] shadow-2xl overflow-hidden flex flex-col relative border-[10px] border-black">
        
        <div id="notch" class="absolute top-0 left-1/2 -translate-x-1/2 w-36 h-8 bg-black rounded-b-2xl z-50"></div>

        <main class="flex-grow flex flex-col px-3 pt-10 pb-1 overflow-y-auto">

            <!-- MODIFIED: Reduced bottom margin --><div class="flex justify-between items-center mb-2">
                <div class="flex flex-col">
                    <h1 class="text-3xl font-black text-tamagotchi-pink-dark" style="font-family: 'Luckiest Guy', cursive;">Donut Miner</h1> <!-- Renamed Title & Applied Font --><!-- REMOVED "mmm, donuts" tagline --></div>
                <div class="flex space-x-2">
                    <button id="dark-mode-toggle-button" class="bg-tamagotchi-button-teal text-white text-lg w-10 h-10 flex items-center justify-center rounded-tamagotchi-md shadow-tamagotchi active:opacity-80">
                        üåô
                    </button>
                    <!-- Updated Audio Button -->
                    <button id="music-toggle-button" class="bg-tamagotchi-button-pink text-white text-lg w-10 h-10 flex items-center justify-center rounded-tamagotchi-md shadow-tamagotchi active:opacity-80">
                        üîá
                    </button>
                    <!-- NEW SFX Button -->
                    <button id="sfx-toggle-button" class="bg-tamagotchi-button-teal text-white text-lg w-10 h-10 flex items-center justify-center rounded-tamagotchi-md shadow-tamagotchi active:opacity-80">
                        üîä
                    </button>
                </div>
            </div>

            <!-- =============================================================== --><!-- GLAZERY VIEW (Restored)                                       --><!-- =============================================================== --><!-- MODIFIED: Removed space-y-1 --><div id="view-glazery" class="flex-grow flex flex-col">
                <h2 class="text-2xl font-black text-tamagotchi-pink-dark mb-1">Glazery</h2>
                
                <!-- ADDED SUBTITLE --><!-- MODIFIED: Changed margins from -mt-2 mb-0 to mb-2 --><p class="text-sm text-gray-500 mb-2" style="font-family: 'Comic Neue', cursive;">
                    Pay the Glaze Price to become KING GLAZER and earn 20% of $DONUT emissions until someone takes the spot after you.
                </p>
                <!-- END ADDED SUBTITLE --><!-- MODIFIED: Reduced padding from p-3 to p-2 --><div class="bg-tamagotchi-card rounded-tamagotchi-lg shadow-tamagotchi p-2 grid grid-cols-3 gap-2">
                    <div class="text-center">
                        <div class="text-xs text-gray-500 font-semibold">Glazer</div> <!-- CHANGED: Baker -> Glazer -->
                        <!-- MODIFIED: Reduced text size from text-base to text-sm --><div id="bakery-king-status" class="font-extrabold text-sm truncate text-tamagotchi-dark">None</div>
                    </div>
                    <div class="text-center">
                        <div class="text-xs text-gray-500 font-semibold">Donuts/s</div> <!-- CHANGED: Cookies/s -> Donuts/s -->
                        <!-- MODIFIED: Reduced text size from text-base to text-sm --><div class="font-extrabold text-sm text-tamagotchi-dark">üç© <span id="bakery-cps">0.00</span></div>
                    </div>
                    <div class="text-center">
                        <div class="text-xs text-gray-500 font-semibold">Glaze Time</div> <!-- CHANGED: Baked -> Glaze Time -->
                        <!-- MODIFIED: Reduced text size from text-base to text-sm --><div class="font-extrabold text-sm text-tamagotchi-dark"><span id="bakery-baked">00:00:00</span></div> <!-- CHANGED: üç© 0 -> 00:00:00 -->
                    </div>
                </div>

                <!-- MODIFIED: Reduced top/bottom margin in ticker wrap --><div id="top-ticker" class="ticker-wrap" style="margin-bottom: 4px;">
                    <div class="ticker-move">
                        <span>Glazing Price doubles with each Glaze, then cools off back to $0 over 24 hrs. 90% of Glaze Price goes to the Glazer being replaced. ... Glazing Price doubles with each Glaze, then cools off back to $0 over 24 hrs. 90% of Glaze Price goes to the Glazer being replaced. ... </span>
                    </div>
                </div>

                <!-- MODIFIED: Removed flex-grow and set a specific height (h-64) to shrink the canvas container --><div id="cookie-rain-container" class="relative h-64 flex items-center justify-center overflow-hidden bg-tamagotchi-card rounded-tamagotchi-lg shadow-tamagotchi glitch-static">
                    <div class="falling-snow"></div>
                    <canvas id="cookie-canvas"></canvas>
                    <button id="glaze-color-button" class="shadow-tamagotchi bg-white text-tamagotchi-dark">üé®</button>
                    <!-- NEW: Zoom Slider -->
                    <input id="glazery-zoom-slider" type="range" class="zoom-slider">
                </div>

                <!-- MODIFIED: Reduced top/bottom margin in ticker wrap --><div id="bottom-ticker" class="ticker-wrap" style="margin-top: 4px;">
                    <div class="ticker-move-reverse">
                        <span>Glazing Price doubles with each Glaze, then cools off back to $0 over 24 hrs. 90% of Glaze Price goes to the Glazer being replaced. ... Glazing Price doubles with each Glaze, then cools off back to $0 over 24 hrs. 90% of Glaze Price goes to the Glazer being replaced. ... </span>
                    </div>
                </div>
                
                <!-- MODIFIED: Reduced padding from p-3 to p-2 --><div class="bg-tamagotchi-card text-tamagotchi-dark p-2 rounded-tamagotchi-lg shadow-tamagotchi">
                    <div class="flex justify-between items-center">
                        <div>
                            <div class="text-xs font-semibold text-gray-600">Glaze Price</div>
                            <!-- MODIFIED: Reduced text size from text-2xl to text-xl --><div class="text-xl font-extrabold text-tamagotchi-dark">$23.23</div>
                            <div class="text-xs text-gray-500">$400.00 available</div>
                        </div>
                        <!-- MODIFIED: Reduced text size from text-base to text-sm --><button id="bakery-action-button" class="bg-tamagotchi-button-pink text-white py-2 px-6 rounded-tamagotchi-md text-sm font-bold active:opacity-80 disabled:opacity-50 shadow-tamagotchi">
                            Glaze
                        </button>
                    </div>
                </div>
            </div>

            <!-- =============================================================== --><!-- ABOUT VIEW (Restored)                                         --><!-- =============================================================== --><div id="view-about" class="hidden flex-grow flex flex-col space-y-3">
                <!-- REMOVED: <h2 class="text-2xl font-black text-tamagotchi-pink-dark">About Kissaki „ÉÑ</h2> -->

                <div class="bg-tamagotchi-card rounded-tamagotchi-lg shadow-tamagotchi p-4 space-y-4 text-tamagotchi-dark">
                    <p class="font-bold text-lg" style="font-family: 'Comic Neue', cursive;">
                        Hello and welcome to Donut Miner!
                    </p>
                    <p class="text-sm font-semibold text-tamagotchi-pink-dark">
                        There are two ways to earn $DONUT:
                    </p>
                    <p class="text-sm">
                        <strong>Plain mining</strong> - everyone can do this at once. Acquire and upgrade bakery items to increase your mining power and earn more $DONUT.
                    </Please>
                    <p class="text-sm">
                        <strong>Glazing</strong> - only one person can glaze at a time. KING GLAZER mines 20% of the $DONUT emissions while glazing. Pay the Glaze price to take over as KING GLAZER.
                    </p>
                </div>

                <!-- NEW: Global Donut Stats -->
                <h3 class="text-xl font-bold text-tamagotchi-pink-dark pt-2">Global Donut Stats</h3>
                <div class="bg-tamagotchi-card rounded-tamagotchi-lg shadow-tamagotchi p-4 space-y-3 text-tamagotchi-dark">
                    
                    <div class="flex justify-between items-center">
                        <span class="text-sm font-semibold text-gray-600">Total Donut Supply</span>
                        <span id="about-total-supply" class="font-extrabold text-tamagotchi-dark">üç© 0</span>
                    </div>
                    
                    <div class="flex justify-between items-center">
                        <span class="text-sm font-semibold text-gray-600">Total % Mined</span>
                        <span id="about-percent-mined" class="font-extrabold text-tamagotchi-dark">0.00%</span>
                    </div>

                    <div class="flex justify-between items-center">
                        <span class="text-sm font-semibold text-gray-600">Time Until Halving</span>
                        <span id="about-next-halving" class="font-extrabold text-tamagotchi-dark">--:--:--</span>
                    </div>

                    <div class="flex justify-between items-center">
                        <span class="text-sm font-semibold text-gray-600">Total Miners</span>
                        <span id="about-total-miners" class="font-extrabold text-tamagotchi-dark">üë§ 0</span>
                    </div>

                </div>
                <!-- END NEW SECTION -->

            </div>
            <!-- =============================================================== --><!-- BAKERY VIEW (Restored)                                        --><!-- =============================================================== --><div id="view-bakery" class="hidden flex-grow flex flex-col space-y-1"> <!-- Renamed ID: view-store -> view-bakery -->
                
                <!-- NEWLY ADDED TITLE AND SUBTITLE -->
                <h2 class="text-2xl font-black text-tamagotchi-pink-dark mb-1">Bakery</h2>
                <!-- MODIFIED -->
                <p class="text-sm text-gray-500 mb-2" style="font-family: 'Comic Neue', cursive;">
                    Purchase and upgrade your bakery items to increase your passive mining rate of $DONUT
                </p>
                <!-- END MODIFIED -->

                <!-- Top Header Stats --><!-- MODIFIED: Reduced padding from p-3 to p-2 --><div class="bg-tamagotchi-card rounded-tamagotchi-lg shadow-tamagotchi p-2 grid grid-cols-2 gap-2">
                    <div class="text-center">
                        <div class="text-xs text-gray-500 font-semibold">Your Mining %</div>
                        <!-- MODIFIED: Reduced text size from text-base to text-sm -->
                        <!-- NOTE: The span inside is the target 'bakery-total-cookies' -->
                        <div class="font-extrabold text-sm text-tamagotchi-dark"><span id="bakery-total-cookies">0.00</span>%</div>
                    </div>
                    <div class="text-center">
                        <div class="text-xs text-gray-500 font-semibold">Claimable Donuts</div>
                        <!-- MODIFIED: Reduced text size from text-base to text-sm --><div class="font-extrabold text-sm text-tamagotchi-dark">üç© <span id="bakery-global-cps">0.00</span></div>
                    </div>
                    <!-- NEW STATS -->
                    <div class="text-center">
                        <div class="text-xs text-gray-500 font-semibold">Mining Power</div>
                        <!-- MODIFIED: Reduced text size from text-base to text-sm --><div class="font-extrabold text-sm text-tamagotchi-dark">‚ö° <span id="bakery-mining-power">0</span></div>
                    </div>
                    <div class="text-center">
                        <div class="text-xs text-gray-500 font-semibold">Donut Balance</div>
                        <!-- MODIFIED: Reduced text size from text-base to text-sm --><div class="font-extrabold text-sm text-tamagotchi-dark">üç© <span id="bakery-donut-balance">0</span></div>
                    </div>
                </div>
                
                <!-- NEW: 3D Item Viewer --><!-- MODIFIED: Adjusted margins, h-48 to h-40 (192px -> 160px) --><div id="bakery-3d-container" class="relative h-40 flex items-center justify-center overflow-hidden bg-tamagotchi-card rounded-tamagotchi-lg shadow-tamagotchi glitch-static my-1">
                    <div class="falling-snow"></div>
                    <canvas id="bakery-item-canvas"></canvas>
                    <!-- NEW: Zoom Slider -->
                    <input id="bakery-zoom-slider" type="range" class="zoom-slider">
                </div>
                <!-- END 3D Item Viewer -->

                <!-- NEW: Item Description Ticker --><!-- MODIFIED: Adjusted margins --><div id="bakery-item-ticker" class="ticker-wrap hidden" style="margin-top: 4px; margin-bottom: 4px;">
                    <div class="ticker-move">
                        <span id="bakery-item-ticker-text">Select an item to see its description...</span>
                    </div>
                </div>
                <!-- END NEW Ticker -->

                <!-- NEW: Power Breakdown Bar Chart Container --><div id="bakery-power-chart-container" class="hidden bg-tamagotchi-card rounded-tamagotchi-lg shadow-tamagotchi p-3 text-tamagotchi-dark space-y-2">
                    <h4 class="text-sm font-bold text-center text-gray-600">Mining Power Breakdown</h4>
                    <div id="power-bar" class="w-full h-4 flex rounded-full overflow-hidden border border-tamagotchi-subtle bg-gray-200">
                        <!-- Bars will be injected by JS --></div>
                    <div id="power-bar-legend" class="flex flex-wrap justify-center gap-x-3 gap-y-1 text-xs">
                        <!-- Legend will be injected by JS --></div>
                </div>

                <!-- MODIFIED: Reduced padding and spacing from p-3 space-y-3 to p-2 space-y-2 --><div id="bakery-item-purchase-controls" class="bg-tamagotchi-card rounded-tamagotchi-lg shadow-tamagotchi p-2 text-tamagotchi-dark space-y-2">
                    <!-- NEW POSITION: Previous/Next Buttons at the very top --><div class="flex justify-between items-center -mt-1 mb-1">
                        <button id="item-info-prev-button" class="bg-tamagotchi-button-teal text-white w-8 h-8 flex items-center justify-center rounded-tamagotchi-md text-base font-bold active:opacity-80 disabled:opacity-50 shadow-tamagotchi p-0">
                            &lt;
                        </button>
                        <h4 class="text-sm font-bold text-gray-600">Selected Item</h4>
                        <button id="item-info-next-button" class="bg-tamagotchi-button-teal text-white w-8 h-8 flex items-center justify-center rounded-tamagotchi-md text-base font-bold active:opacity-80 disabled:opacity-50 shadow-tamagotchi p-0">
                            &gt;
                        </button>
                    </div>

                    <div id="bakery-item-info-stats">
                        <div class="text-center text-gray-500 text-sm p-2">
                            Select an item from the list below to see its details.
                        </div>
                    </div>
                    
                    <div class="space-y-2">
                        <div class="flex justify-between items-center space-x-2">
                            <span id="item-info-amount-label" class="text-sm font-semibold text-gray-600 w-24">Amount: 1</span>
                            <input id="item-info-slider" type="range" min="1" max="1" value="1" class="flex-grow" disabled>
                            <button id="item-info-max-button" class="bg-tamagotchi-button-teal text-white text-xs px-2 py-1 rounded-tamagotchi-md shadow-tamagotchi active:opacity-80 disabled:opacity-50" disabled>
                                Max
                            </button>
                        </div>
                        <div class="grid grid-cols-2 gap-2">
                            <button id="item-info-purchase-button" class="w-full bg-tamagotchi-button-pink text-white p-2 rounded-tamagotchi-lg text-sm font-bold active:opacity-80 disabled:opacity-50 shadow-tamagotchi" disabled>
                                Purchase
                            </button>
                            <button id="item-info-upgrade-button" class="w-full bg-gray-300 text-gray-500 p-2 rounded-tamagotchi-lg text-sm font-bold disabled:opacity-50 shadow-tamagotchi" disabled>
                                Upgrade
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Container for list, set to flex-col to manage grow/shrink --><div class="flex-grow overflow-hidden pt-1 pb-2 flex flex-col">
                    <!-- Collapsible header --><div id="item-list-toggle" class="flex justify-between items-center cursor-pointer mb-1">
                        <h3 class="text-xs font-bold text-gray-500 uppercase mt-2 tracking-wide">Items</h3>
                        <span id="item-list-toggle-icon" class="text-lg text-gray-500 transform transition-transform duration-200">üîΩ</span>
                    </div>

                    <!-- List container that will scroll --><div id="bakery-item-list-container" class="flex-grow overflow-y-auto">
                        <div id="bakery-item-list" class="space-y-2">
                            <!-- Item list will be populated by JS --></div>
                    </div>
                </div>
                
            </div>

        </main>

        <nav class="grid grid-cols-3 gap-2 p-1 border-t border-tamagotchi-subtle bg-tamagotchi-card shadow-lg">
            <button id="nav-bakery" class="nav-icon active flex flex-col items-center justify-center p-2 rounded-tamagotchi-md"> <!-- Renamed ID: nav-store -> nav-bakery --><span>üè¨</span>
            </button>
            <button id="nav-glazery" class="nav-icon flex flex-col items-center justify-center p-2 rounded-tamagotchi-md"> <!-- Renamed ID: nav-miner -> nav-glazery --><span>üç©</span>
            </button>
            <button id="nav-about" class="nav-icon flex flex-col items-center justify-center p-2 rounded-tamagotchi-md">
                <span>‚ÑπÔ∏è</span>
            </button>
        </nav>

    </div> 

<script>
        document.addEventListener('DOMContentLoaded', () => {

            // ===============================================================
            // GAME STATE
            // ===============================================================
            
            const state = {
                // Player State
                player: {
                    cookies: 1000000,
                    isBakerKing: false,
                    claimableBakeryCookies: 0,
                    totalBakedCookies: 0, // Mockup has "Baked"
                    glazeStartTime: null, // NEW: Timer for Glaze Time
                    claimableFactoryCookies: 0,
                    productionPower: 0,
                    factoryCapacity: 250,
                    items: { // Renamed: buildings -> items
                        egg: 0, // NEW ITEM
                        milk: 0, // NEW ITEM
                        cherries: 0, // NEW ITEM
                        bacon: 0, // NEW ITEM
                    cookie: 0, // NEW ITEM
                    blicky: 0, // CHANGED: cursor -> blicky
                    grandma: 0,
                    grapes: 0, // CHANGED: farm -> grapes
                        mine: 0,
                        factory: 0,
                    }
                },
                // Global Game State
                global: {
                    emissionRate: 10,
                    totalCookiesCreated: 0,
                    nextHalvingAt: 1000000,
                    totalProductionPower: 1,
                    totalDonutSupply: 1000000000, // NEW (Changed to 1 Billion)
                    totalMiners: 1234, // NEW (mock value)
                },
                // Item Definitions (using emojis from mockups) // Renamed: Building -> Item
                items: { // Renamed: buildings -> items
                    egg:     { name: 'Egg',     emoji: 'ü•ö', baseCost: 10,    basePower: 0.5, description: "A simple, humble egg. The start of any great pastry." }, // NEW ITEM
                    milk:    { name: 'Milk',    emoji: 'ü•õ', baseCost: 20,    basePower: 1,   description: "Fresh, creamy milk. Essential for a moist donut." }, // NEW ITEM
                    cherries:{ name: 'Cherries',emoji: 'üçí', baseCost: 45,    basePower: 2,   description: "Sweet and tart! Adds a fruity kick to your baking." }, // NEW ITEM
                    bacon:   { name: 'Bacon',   emoji: 'ü•ì', baseCost: 100,   basePower: 5,   description: "Salty, smoky, and... on a donut? Don't knock it 'til you try it." }, // NEW ITEM
                    cookie:  { name: 'Cookie',  emoji: 'üç™', baseCost: 140,   basePower: 6,   description: "A cookie on a donut? We've gone full meta." }, // NEW ITEM
                    blicky:  { name: 'Blicky',  emoji: 'üî´', baseCost: 35,    basePower: 1,   description: "It... 'clicks'... for you. Yeah, 'clicks'." }, // CHANGED: from cursor
                    grandma: { name: 'Grandma', emoji: 'üëµ', baseCost: 175,   basePower: 5,   description: "A sweet old grandma, baking with love (and secret recipes)." },
                    grapes:  { name: 'Grapes',  emoji: 'üçá', baseCost: 1455,  basePower: 25,  description: "Bunches of sweet, sugary grapes. Perfect for... donut wine?" }, // CHANGED: from farm
                    mine:    { name: 'Mine',    emoji: '‚õèÔ∏è', baseCost: 12000, basePower: 100, description: "Mines for pure, crystallized donut-sugar." },
                    factory: { name: 'Factory', emoji: 'üè≠', baseCost: 130000,basePower: 500, description: "Mass-produces donuts on an industrial scale." },
                },
                // UI State
                ui: {
                    activeView: 'bakery', // Renamed: store -> bakery
                    selectedItem: null, // Renamed: selectedBuilding -> selectedItem
                    isDarkMode: false, // NEW
                    isItemListCollapsed: true, // CHANGED: Start collapsed
                    isSfxMuted: false // NEW
                }
            };

            // ===============================================================
            // DOM ELEMENTS
            // ===============================================================
            const dom = {
                views: {
                    glazery: document.getElementById('view-glazery'), // Renamed: miner -> glazery
                    about: document.getElementById('view-about'),
                    bakery: document.getElementById('view-bakery'), // Renamed: store -> bakery
                },
                aboutPage: { // NEW
                    totalSupply: document.getElementById('about-total-supply'),
                    percentMined: document.getElementById('about-percent-mined'),
                    nextHalving: document.getElementById('about-next-halving'),
                    totalMiners: document.getElementById('about-total-miners'),
                },
                nav: {
                    glazery: document.getElementById('nav-glazery'), // Renamed: miner -> glazery
                    about: document.getElementById('nav-about'),
                    bakery: document.getElementById('nav-bakery'), // Renamed: store -> bakery
                },
                glazery: { // Renamed: miner -> glazery
                    kingStatus: document.getElementById('bakery-king-status'),
                    cps: document.getElementById('bakery-cps'),
                    baked: document.getElementById('bakery-baked'),
                    actionButton: document.getElementById('bakery-action-button'),
                    canvas: document.getElementById('cookie-canvas'),
                    rainContainer: document.getElementById('cookie-rain-container'),
                    glazeColorButton: document.getElementById('glaze-color-button'),
                    zoomSlider: document.getElementById('glazery-zoom-slider'), // NEW
                },
                bakeryPage: { // Renamed: store -> bakeryPage
                    totalCookies: document.getElementById('bakery-total-cookies'), // Renamed ID
                    globalCps: document.getElementById('bakery-global-cps'), // Renamed ID
                    itemList: document.getElementById('bakery-item-list'), // Renamed ID
                    miningPower: document.getElementById('bakery-mining-power'), // NEW
                    donutBalance: document.getElementById('bakery-donut-balance'), // NEW
                    container: document.getElementById('bakery-3d-container'), // NEW
                    canvas: document.getElementById('bakery-item-canvas'), // NEW
                    itemInfoStats: document.getElementById('bakery-item-info-stats'), // NEW
                    slider: document.getElementById('item-info-slider'), // NEW
                    amountLabel: document.getElementById('item-info-amount-label'), // NEW
                    maxButton: document.getElementById('item-info-max-button'), // NEW
                    purchaseButton: document.getElementById('item-info-purchase-button'), // NEW
                    upgradeButton: document.getElementById('item-info-upgrade-button'), // NEW
                    itemInfoContainer: document.getElementById('bakery-item-purchase-controls'), // NEW
                    prevButton: document.getElementById('item-info-prev-button'), // NEW
                    nextButton: document.getElementById('item-info-next-button'), // NEW
                    // NEW: Collapsible list elements
                    itemListToggle: document.getElementById('item-list-toggle'),
                    itemListToggleIcon: document.getElementById('item-list-toggle-icon'),
                    itemListContainer: document.getElementById('bakery-item-list-container'),
                    // NEW: Power bar elements
                    powerChartContainer: document.getElementById('bakery-power-chart-container'),
                    powerBar: document.getElementById('power-bar'),
                    powerBarLegend: document.getElementById('power-bar-legend'),
                    // NEW: Item ticker
                    itemTickerWrap: document.getElementById('bakery-item-ticker'),
                    itemTickerText: document.getElementById('bakery-item-ticker-text'),
                    zoomSlider: document.getElementById('bakery-zoom-slider'), // NEW
                },
                musicToggleButton: document.getElementById('music-toggle-button'), // RENAMED from audioToggleButton
                sfxToggleButton: document.getElementById('sfx-toggle-button'), // NEW
                darkModeToggleButton: document.getElementById('dark-mode-toggle-button') // NEW
            };

            // ===============================================================
            // HELPER FUNCTIONS
            // ===============================================================

            const format = (num) => Math.floor(num).toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, '$1,');
            const formatDecimal = (num) => num.toFixed(2);
            // NEW: Helper function to format milliseconds into HH:MM:SS
            const formatGlazeTime = (ms) => {
                if (ms === null || ms < 0) {
                    return '00:00:00';
                }
                const totalSeconds = Math.floor(ms / 1000);
                const hours = Math.floor(totalSeconds / 3600);
                const minutes = Math.floor((totalSeconds % 3600) / 60);
                const seconds = totalSeconds % 60;
                
                return [hours, minutes, seconds]
                    .map(v => v.toString().padStart(2, '0'))
                    .join(':');
            };

            const getItemCost = (name) => { // Renamed: getBuildingCost -> getItemCost
                const def = state.items[name]; // Renamed: buildings -> items
                const count = state.player.items[name]; // Renamed: buildings -> items
                return Math.floor(def.baseCost * Math.pow(1.15, count));
            };

            // NEW: Helper function to calculate cost of buying in bulk
            const getBulkItemCost = (name, amount) => {
                let totalCost = 0;
                const def = state.items[name];
                const currentOwned = state.player.items[name];
                for (let i = 0; i < amount; i++) {
                    totalCost += Math.floor(def.baseCost * Math.pow(1.15, currentOwned + i));
                }
                return totalCost;
            };

            // NEW: Helper function to calculate max affordable items (up to 100)
            const calculateMaxAffordable = (name) => {
                let maxAffordable = 0;
                let cookies = state.player.cookies;
                const def = state.items[name];
                const currentOwned = state.player.items[name];
                for (let i = 0; i < 100; i++) { // Set a hard cap of 100 for the slider
                    let nextCost = Math.floor(def.baseCost * Math.pow(1.15, currentOwned + i));
                    if (cookies >= nextCost) {
                        cookies -= nextCost;
                        maxAffordable++;
                    } else {
                        break; // Can't afford the next one
                    }
                }
                return Math.max(1, maxAffordable); // Always allow at least 1, even if unaffordable (button will be disabled)
            };

            const calculatePlayerProductionPower = () => {
                let totalPower = 0;
                for (const name in state.player.items) { // Renamed: buildings -> items
                    const def = state.items[name]; // Renamed: buildings -> items
                    const count = state.player.items[name]; // Renamed: buildings -> items
                    totalPower += count * def.basePower;
                }
                return totalPower;
            };

            // ===============================================================
            // AUDIO SETUP (Tone.js)
            // ===============================================================
            let kick, hiHat, bass, melody;
            let kickSequence, hiHatSequence, bassSequence, melodySequence;
            let isMusicPlaying = false;
            let isAudioInitialized = false;

            // NEW: SFX
            let purchaseSound, cuteClickSound; // REMOVED crunchSound, RENAMED clickSound

            function initAudio() {
                if (isAudioInitialized) return;

                // Set tempo, swing, and a limiter for all audio
                Tone.Transport.bpm.value = 140;
                Tone.Transport.swing = 0.2; // Add that "swing" feel
                Tone.Transport.swingSubdivision = '8n';
                const limiter = new Tone.Limiter(-6).toDestination();

                // 1. KICK DRUM (The "OOM")
                kick = new Tone.MembraneSynth({
                    pitchDecay: 0.01,
                    octaves: 6,
                    oscillator: { type: 'sine' },
                    envelope: {
                        attack: 0.001,
                        decay: 0.3,
                        sustain: 0.01,
                        release: 0.2
                    }
                }).connect(limiter);

                // Polka kick pattern (16 measures, on beats 1 & 3)
                const kickPattern = [
                    'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null,
                    'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null,
                    'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null,
                    'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null,
                    'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null,
                    'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null,
                    'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null,
                    'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null
                ];
                
                kickSequence = new Tone.Sequence((time, note) => {
                    if (note) kick.triggerAttackRelease(note, '8n', time);
                }, kickPattern, '8n');
                kickSequence.loop = true;

                // 2. HI-HAT (The "pah")
                hiHat = new Tone.NoiseSynth({
                    noise: { type: 'white' },
                    envelope: {
                        attack: 0.001,
                        decay: 0.05,
                        sustain: 0,
                        release: 0.05
                    }
                }).connect(limiter);

                // Polka hi-hat pattern (16 measures, on beats 2 & 4)
                const hiHatPattern = [
                    null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null,
                    null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null,
                    null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null,
                    null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null,
                    null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null,
                    null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null,
                    null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null,
                    null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null
                ];

                hiHatSequence = new Tone.Sequence((time, note) => {
                    if (note) hiHat.triggerAttackRelease('8n', time);
                }, hiHatPattern, '8n');
                hiHatSequence.loop = true;

                // 3. BASS LINE (Driving polka-style)
                bass = new Tone.MonoSynth({
                    oscillator: { type: 'sawtooth' },
                    filter: { Q: 2, type: 'lowpass', cutoff: 400 },
                    envelope: {
                        attack: 0.01,
                        decay: 0.2,
                        sustain: 0.3,
                        release: 0.5
                    }
                }).connect(limiter);

                // 16-measure (I-VI-IV-V) progression in C Minor
                // Cm (C,G) | G# (G#,D#) | Fm (F,C) | G (G,D)
                const bassPattern = [
                    // Cm (4 measures)
                    'C2', null, 'G2', null, 'C2', null, 'G2', null, 'C2', null, 'G2', null, 'C2', null, 'G2', null,
                    'C2', null, 'G2', null, 'C2', null, 'G2', null, 'C2', null, 'G2', null, 'C2', null, 'G2', null,
                    // G# (4 measures)
                    'G#1', null, 'D#2', null, 'G#1', null, 'D#2', null, 'G#1', null, 'D#2', null, 'G#1', null, 'D#2', null,
                    'G#1', null, 'D#2', null, 'G#1', null, 'D#2', null, 'G#1', null, 'D#2', null, 'G#1', null, 'D#2', null,
                    // Fm (4 measures)
                    'F1', null, 'C2', null, 'F1', null, 'C2', null, 'F1', null, 'C2', null, 'F1', null, 'C2', null,
                    'F1', null, 'C2', null, 'F1', null, 'C2', null, 'F1', null, 'C2', null, 'F1', null, 'C2', null,
                    // G (4 measures)
                    'G1', null, 'D2', null, 'G1', null, 'D2', null, 'G1', null, 'D2', null, 'G1', null, 'D2', null,
                    'G1', null, 'D2', null, 'G1', null, 'D2', null, 'G1', null, 'D2', null, 'G1', null, 'D2', 'D2' // Walk up
                ];

                bassSequence = new Tone.Sequence((time, note) => {
                    if (note) bass.triggerAttackRelease(note, '8n', time);
                }, bassPattern, '8n');
                bassSequence.loop = true;

                // 4. MELODY (Cute & Relaxing)
                melody = new Tone.FMSynth({
                    harmonicity: 3,
                    modulationIndex: 10,
                    oscillator: { type: 'sine' },
                    envelope: {
                        attack: 0.01,
                        decay: 0.2,
                        sustain: 0.1,
                        release: 0.5
                    }
                }).connect(limiter);

                // 16-measure melody corresponding to the bass progression
                const melodyPattern = [
                    // Cm
                    'G4', 'A#4', 'C5', null, 'G4', 'D#4', null, null, 'G4', 'A#4', 'C5', null, 'D#5', 'C5', 'A#4', null,
                    'G4', 'A#4', 'C5', null, 'G4', 'D#4', null, null, 'G4', 'A#4', 'G4', 'D#4', 'C4', null, null, null,
                    // G#
                    'G#4', 'C5', 'D#5', null, 'C5', 'G#4', null, null, 'G#4', 'C5', 'D#5', null, 'F5', 'D#5', 'C5', null,
                    'G#4', 'C5', 'D#5', null, 'C5', 'G#4', null, null, 'C5', 'A#4', 'G#4', 'F4', 'D#4', null, null, null,
                    // Fm
                    'F4', 'G#4', 'C5', null, 'G#4', 'F4', null, null, 'F4', 'G#4', 'C5', null, 'D#5', 'C5', 'G#4', null,
                    'F4', 'G#4', 'C5', null, 'G#4', 'F4', null, null, 'F4', 'G#4', 'F4', 'D#4', 'C4', null, null, null,
                    // G
                    'G4', 'B4', 'D5', null, 'D5', 'B4', 'G4', null, 'G4', 'B4', 'D5', 'F5', 'D5', 'B4', 'G4', null,
                    'A#4', null, 'B4', null, 'C5', null, 'B4', 'A#4', 'G4', 'F4', 'D#4', 'D4', 'C4', null, null, null
                ];
                
                melodySequence = new Tone.Sequence((time, note) => {
                    if (note) melody.triggerAttackRelease(note, '8n', time);
                }, melodyPattern, '8n');
                melodySequence.loop = true;

                // NEW: Initialize SFX
                // REMOVED: crunchSound (NoiseSynth)

                // NEW: Changed from MembraneSynth to a "cuter" FMSynth
                cuteClickSound = new Tone.FMSynth({
                    oscillator: { type: 'sine' },
                    envelope: {
                        attack: 0.001,
                        decay: 0.05,
                        sustain: 0,
                        release: 0.1
                    },
                    harmonicity: 0.5, // Makes it a bit bell-like
                    modulationIndex: 2
                }).connect(limiter);
                
                purchaseSound = new Tone.Synth({
                    oscillator: { type: 'triangle' },
                    envelope: {
                        attack: 0.01,
                        decay: 0.1,
                        sustain: 0.1,
                        release: 0.2
                    }
                }).connect(limiter);
                // --- End SFX Init ---

                isAudioInitialized = true;
            }

            // NEW: Play SFX function
            function playSoundEffect(sound, ...args) {
                if (state.ui.isSfxMuted) return;

                // Start audio context on first user interaction
                if (Tone.context.state !== 'running') {
                    Tone.start();
                }
                
                // Initialize audio if it hasn't been already
                if (!isAudioInitialized) {
                    initAudio();
                }
                
                if (!state.ui.isSfxMuted) { // Double check after init
                    if (sound === 'crunch') {
                        // REMOVED: crunchSound trigger
                        // MODIFIED: Use new sound and higher pitch (C6)
                        cuteClickSound.triggerAttackRelease('C6', '32n', Tone.now());
                    }
                    if (sound === 'purchase') {
                        // Play a "cha-ching" like arpeggio
                        purchaseSound.triggerAttackRelease('C5', '16n', Tone.now());
                        purchaseSound.triggerAttackRelease('E5', '16n', Tone.now() + 0.05);
                        purchaseSound.triggerAttackRelease('G5', '16n', Tone.now() + 0.1);
                    }
                }
            }
            
            // NEW: Toggle SFX function
            function toggleSfx() {
                state.ui.isSfxMuted = !state.ui.isSfxMuted;
                dom.sfxToggleButton.textContent = state.ui.isSfxMuted ? 'üîá' : 'üîä';

                // Play a sound on enable
                if (!state.ui.isSfxMuted) {
                    playSoundEffect('crunch');
                }
            }


            function toggleMusic() {
                 // Start audio context on first user interaction
                if (Tone.context.state !== 'running') {
                    Tone.start();
                }

                if (!isAudioInitialized) {
                    initAudio();
                }

                if (isMusicPlaying) {
                    Tone.Transport.stop();
                    // Stop all sequences
                    if (kickSequence) kickSequence.stop();
                    if (hiHatSequence) hiHatSequence.stop();
                    if (bassSequence) bassSequence.stop();
                    if (melodySequence) melodySequence.stop();
                    
                    dom.musicToggleButton.textContent = 'üîá';
                } else {
                    Tone.Transport.start();
                    // Start all sequences
                    if (kickSequence) kickSequence.start(0);
                    if (hiHatSequence) hiHatSequence.start(0);
                    if (bassSequence) bassSequence.start(0);
                    if (melodySequence) melodySequence.start(0);

                    dom.musicToggleButton.textContent = 'üéµ';
                }
                isMusicPlaying = !isMusicPlaying;
            }

            // ===============================================================
            // DARK MODE TOGGLE (NEW)
            // ===============================================================
            function toggleDarkMode() {
                state.ui.isDarkMode = !state.ui.isDarkMode;
                const appShell = document.getElementById('app-shell');
                if (state.ui.isDarkMode) {
                    appShell.classList.add('dark');
                    dom.darkModeToggleButton.textContent = '‚òÄÔ∏è';
                } else {
                    appShell.classList.remove('dark');
                    dom.darkModeToggleButton.textContent = 'üåô';
                }
                // NEW: Update bar chart if visible
                if (state.ui.isItemListCollapsed) {
                    renderPowerBarChart();
                }
            }

            // ===============================================================
            // 3D GLAZERY SETUP
            // ===============================================================

            let scene, camera, renderer, donutGroup, glazeMaterial;
            let isDragging = false;
            let previousPointerX = 0;
            let previousPointerY = 0;
            let initialPinchDistance = 0;
            let currentCameraZ = 10;
            let isThreeJSInitialized = false; 

            const MIN_ZOOM_Z = 3;
            const MAX_ZOOM_Z = 20;

            const glazeColors = [
                0xFFC0CB, // Original Pink
                0xADD8E6, // Light Blue
                0x90EE90, // Light Green
                0xFFD700, // Gold (Yellow)
                0x800080, // Purple
                0xFFF8DC, // Cream
                0xFF0000, // Red
                0x000000  // Black
            ];
            let currentGlazeColorIndex = 0;


            // Helper function to create a basic crack texture on a canvas
            function createCrackTexture(size = 1024) { // Increased size
                const canvas = document.createElement('canvas');
                canvas.width = size;
                canvas.height = size;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = 'white'; // Bump maps use grayscale: white = high, black = low
                ctx.fillRect(0, 0, size, size);

                // Draw some random cracks
                ctx.strokeStyle = '#333333'; // Darker color for cracks (appears lower)
                ctx.lineWidth = 3; // Thicker lines
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                for (let i = 0; i < 15; i++) { // More cracks
                    ctx.beginPath();
                    let startX = Math.random() * size;
                    let startY = Math.random() * size;
                    ctx.moveTo(startX, startY);
                    let len = Math.random() * 60 + 30; // Slightly longer cracks
                    let currentX = startX;
                    let currentY = startY;
                    for (let j = 0; j < 5; j++) {
                         currentX += (Math.random() - 0.5) * len;
                         currentY += (Math.random() - 0.5) * len;
                         // Clamp coordinates to stay within canvas bounds
                         currentX = Math.max(0, Math.min(size, currentX));
                         currentY = Math.max(0, Math.min(size, currentY));
                        ctx.lineTo(currentX, currentY);
                        len *= 0.8;
                    }
                    ctx.stroke();
                }

                return new THREE.CanvasTexture(canvas);
            }

            // NEW: Helper function to create a blotchy "powder" texture
            function createPowderTexture(size = 512) {
                const canvas = document.createElement('canvas');
                canvas.width = size;
                canvas.height = size;
                const ctx = canvas.getContext('2d');
                
                // Start with a dark background (transparent)
                ctx.fillStyle = 'black'; // Alpha map: black = transparent
                ctx.fillRect(0, 0, size, size);

                // Add white "blotches" (opaque powder)
                for (let i = 0; i < 3000; i++) {
                    const x = Math.random() * size;
                    const y = Math.random() * size;
                    const r = Math.random() * 2 + 1; // Small blotches
                    
                    // Use radial gradient for soft edges
                    const gradient = ctx.createRadialGradient(x, y, 0, x, y, r);
                    const alpha = Math.random() * 0.5 + 0.3; // Varying opacity
                    gradient.addColorStop(0, `rgba(255, 255, 255, ${alpha})`); // White, semi-opaque
                    gradient.addColorStop(1, 'rgba(255, 255, 255, 0)'); // Fades to transparent
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(x, y, r, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Add some denser clumps
                for (let i = 0; i < 50; i++) {
                    const x = Math.random() * size;
                    const y = Math.random() * size;
                    const r = Math.random() * 10 + 5; // Larger clump area
                    
                    for (let j = 0; j < 20; j++) {
                        const clumpX = x + (Math.random() - 0.5) * r;
                        const clumpY = y + (Math.random() - 0.5) * r;
                        const clumpR = Math.random() * 2 + 0.5;
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)'; // Denser powder
                        ctx.beginPath();
                        ctx.arc(clumpX, clumpY, clumpR, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                return new THREE.CanvasTexture(canvas);
            }

            // MOVED: Helper function to create a speckle/noise texture on a canvas
            function createSpeckleTexture(size = 512, color = 'rgba(0,0,0,0.5)') { // Added color param
                const canvas = document.createElement('canvas');
                canvas.width = size;
                canvas.height = size;
                const ctx = canvas.getContext('2d');
                // Use white background so material color shows through
                ctx.fillStyle = '#FFFFFF'; 
                ctx.fillRect(0, 0, size, size);

                // Add random speckles
                for (let i = 0; i < 2000; i++) { // More speckles
                    const x = Math.random() * size;
                    const y = Math.random() * size;
                    const r = Math.random() * 0.8 + 0.4; // Slightly larger speckles
                    const alpha = Math.random() * 0.5 + 0.3; // More opaque speckles
                    
                    // Vary speckle color slightly around black/dark brown
                    const shade = Math.floor(Math.random() * 40); // 0 to 39
                    ctx.fillStyle = `rgba(${shade}, ${shade}, ${shade}, ${alpha})`; 
                    
                    ctx.beginPath();
                    ctx.arc(x, y, r, 0, Math.PI * 2);
                    ctx.fill();
                }

                return new THREE.CanvasTexture(canvas);
            }

            // ===============================================================
            // 3D BAKERY MODELS (MOVED)
            // ===============================================================

            // --- Model Creation Functions ---

            function createEggModel() {
                const eggGroup = new THREE.Group();
                const geometry = new THREE.SphereGeometry(1.5, 32, 32);
                geometry.scale(1, 1.3, 1); // Make it egg-shaped

                const material = new THREE.MeshStandardMaterial({
                    color: 0xFDE5C3, // Pale eggshell color
                    roughness: 0.7,
                    metalness: 0.1,
                });
                const egg = new THREE.Mesh(geometry, material);
                eggGroup.add(egg);
                return eggGroup;
            }

            function createMilkModel() {
                const milkGroup = new THREE.Group();

                // Bottle body
                const bodyGeo = new THREE.CylinderGeometry(0.7, 0.7, 2.0, 32);
                const bodyMat = new THREE.MeshStandardMaterial({
                    color: 0xffffff, // White
                    roughness: 0.2,
                    metalness: 0.1,
                    transparent: true,
                    opacity: 0.8
                });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.position.y = 0;
                milkGroup.add(body);

                // Bottle neck
                const neckGeo = new THREE.CylinderGeometry(0.3, 0.5, 0.5, 32);
                const neckMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.2, opacity: 0.8, transparent: true });
                const neck = new THREE.Mesh(neckGeo, neckMat);
                neck.position.y = 1.25;
                milkGroup.add(neck);

                // Cap
                const capGeo = new THREE.CylinderGeometry(0.3, 0.3, 0.1, 32);
                const capMat = new THREE.MeshStandardMaterial({ color: 0xADD8E6 }); // Light blue cap
                const cap = new THREE.Mesh(capGeo, capMat);
                cap.position.y = 1.55;
                milkGroup.add(cap);
                
                // Scale down the whole model
                milkGroup.scale.set(0.8, 0.8, 0.8);
                milkGroup.position.y = -0.2; // Adjust position

                return milkGroup;
            }

            function createCherriesModel() {
                const cherryGroup = new THREE.Group();
                
                const cherryMat = new THREE.MeshStandardMaterial({
                    color: 0xAA0000, // Deep red
                    roughness: 0.3,
                    metalness: 0.1
                });

                const stemMat = new THREE.MeshStandardMaterial({
                    color: 0x006400, // Dark green
                    roughness: 0.8
                });

                // Cherry 1
                const cherry1Geo = new THREE.SphereGeometry(0.5, 32, 32);
                const cherry1 = new THREE.Mesh(cherry1Geo, cherryMat);
                cherry1.position.set(-0.4, 0, 0);
                cherryGroup.add(cherry1);

                // Cherry 2
                const cherry2Geo = new THREE.SphereGeometry(0.5, 32, 32);
                const cherry2 = new THREE.Mesh(cherry2Geo, cherryMat);
                cherry2.position.set(0.4, 0.1, 0); // Slightly offset
                cherryGroup.add(cherry2);

                // Stem 1
                const stem1Geo = new THREE.CylinderGeometry(0.05, 0.05, 1, 8);
                const stem1 = new THREE.Mesh(stem1Geo, stemMat);
                stem1.position.set(-0.2, 0.5, 0); // Connects to cherry 1
                stem1.rotation.z = Math.PI / 6;
                cherryGroup.add(stem1);

                // Stem 2
                const stem2Geo = new THREE.CylinderGeometry(0.05, 0.05, 1, 8);
                const stem2 = new THREE.Mesh(stem2Geo, stemMat);
                stem2.position.set(0.2, 0.5, 0); // Connects to cherry 2
                stem2.rotation.z = -Math.PI / 6;
                cherryGroup.add(stem2);

                cherryGroup.scale.set(1.5, 1.5, 1.5);
                cherryGroup.position.y = -0.5; // Lower it a bit

                return cherryGroup;
            }
            
            // NEW: Function to create a 3D bacon model
            function createBaconModel() {
                const baconGroup = new THREE.Group();

                // --- 1. Generate a bacon texture ---
                const canvas = document.createElement('canvas');
                const size = 64; // Texture width
                const length = 256; // Texture length
                canvas.width = size;
                canvas.height = length;
                const ctx = canvas.getContext('2d');
                
                // Red meat part
                ctx.fillStyle = '#DD5737';
                ctx.fillRect(0, 0, size, length);
                
                // Fatty streaks (lengthwise)
                ctx.strokeStyle = '#F5E6C1';
                
                const drawStreak = (startX, fatWidth, waviness) => {
                    ctx.beginPath();
                    ctx.moveTo(startX, 0); // Start at top
                    
                    let currentY = 0;
                    let currentX = startX;
                    
                    while (currentY < length) {
                        const segmentLength = 40 + Math.random() * 20; // How long is this piece of the wave
                        const nextY = currentY + segmentLength;
                        
                        // Control point for the wave
                        const controlX = currentX + (Math.random() - 0.5) * waviness;
                        // End point for this segment
                        const endX = startX + (Math.random() - 0.5) * (waviness / 2); // Tend to return to center
                        
                        ctx.quadraticCurveTo(controlX, currentY + segmentLength / 2, endX, nextY);
                        
                        currentX = endX;
                        currentY = nextY;
                    }
                    ctx.lineWidth = fatWidth;
                    ctx.stroke();
                };
                
                drawStreak(size * 0.2, 6, 10); // startX, fatWidth, waviness
                drawStreak(size * 0.5, 8, 15);
                drawStreak(size * 0.8, 5, 10);

                const baconTexture = new THREE.CanvasTexture(canvas);
                baconTexture.wrapS = THREE.RepeatWrapping;
                baconTexture.wrapT = THREE.RepeatWrapping;
                baconTexture.needsUpdate = true;
                
                // --- 2. Create the geometry ---
                const stripGeo = new THREE.PlaneGeometry(0.8, 3, 10, 30); // Width, Length, Width Segs, Length Segs
                const pos = stripGeo.attributes.position;
                
                // Add waves
                for (let i = 0; i < pos.count; i++) {
                    const y = pos.getY(i); // This is the length axis
                    const x = pos.getX(i); // This is the width axis
                    
                    // --- REWORKED WAVINESS ---
                    // More complex wave along the length (y-axis)
                    const zWave = (Math.sin(y * 2.0) * 0.1) + (Math.sin(y * 4.5) * 0.05);
                    // Stronger curl along the width (x-axis)
                    const zCurl = Math.cos(x * Math.PI / 0.8) * 0.2; // Stronger curl
                    
                    pos.setZ(i, zWave + zCurl);
                    // --- END REWORK ---
                }
                stripGeo.computeVertexNormals();
                
                // --- 3. Create the material ---
                const baconMat = new THREE.MeshStandardMaterial({
                    map: baconTexture,
                    roughness: 0.8,
                    side: THREE.DoubleSide // Show texture on both sides
                });
                
                const strip = new THREE.Mesh(stripGeo, baconMat);
                strip.rotation.x = -Math.PI / 2; // Lie flat
                baconGroup.add(strip);
                
                baconGroup.scale.set(1.2, 1.2, 1.2);
                return baconGroup;
            }
            
            // Function to create a 3D cookie model
            function createCookieModel() {
                const cookieGroup = new THREE.Group();

                // --- NEW: Generate a bump texture for the cookie ---
                const canvas = document.createElement('canvas');
                const size = 128; // Texture size
                canvas.width = size;
                canvas.height = size;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#888888'; // Mid-grey base
                ctx.fillRect(0, 0, size, size);
                
                // Add random light/dark spots for bumps
                for (let i = 0; i < 2000; i++) {
                    const x = Math.random() * size;
                    const y = Math.random() * size;
                    const c = Math.random() > 0.5 ? '#999999' : '#777777'; // Lighter or darker grey
                    ctx.fillStyle = c;
                    ctx.fillRect(x, y, 2, 2);
                }
                const bumpTexture = new THREE.CanvasTexture(canvas);
                bumpTexture.wrapS = THREE.RepeatWrapping;
                bumpTexture.wrapT = THREE.RepeatWrapping;
                bumpTexture.needsUpdate = true;
                // --- End of new texture ---

                // Cookie Material - NOW WITH BUMPS
                const cookieMat = new THREE.MeshStandardMaterial({
                    color: 0x8B4513, // Brown
                    roughness: 0.8,
                    bumpMap: bumpTexture, // APPLY THE BUMP MAP
                    bumpScale: 0.03, // Adjust for more/less bumpiness
                    metalness: 0.0
                });

                // Cookie Base
                const geometry = new THREE.CylinderGeometry(1.5, 1.5, 0.3, 32);
                const cookie = new THREE.Mesh(geometry, cookieMat);
                cookieGroup.add(cookie);

                // Chocolate Chips
                const chipGeo = new THREE.ConeGeometry(0.15, 0.2, 8); // Small cone
                
                for (let i = 0; i < 20; i++) {
                    // SLIGHTLY randomized chip color
                    const chipColor = new THREE.Color(0x3B270A).lerp(new THREE.Color(0x1A1206), Math.random() * 0.5);
                    const chipMat = new THREE.MeshStandardMaterial({
                        color: chipColor,
                        roughness: 0.7
                    });
                    
                    const chip = new THREE.Mesh(chipGeo, chipMat);
                    
                    // Random position on top of the cookie
                    const angle = Math.random() * Math.PI * 2;
                    const radius = Math.random() * 1.3; // 1.5 is edge
                    
                    chip.position.x = Math.cos(angle) * radius;
                    chip.position.z = Math.sin(angle) * radius;
                    chip.position.y = 0.15; // On the surface
                    
                    // Random rotation
                    chip.rotation.x = (Math.random() - 0.5) * 0.5;
                    chip.rotation.z = (Math.random() - 0.5) * 0.5;
                    
                    cookieGroup.add(chip);
                }
                
                cookieGroup.position.y = -0.15; // Center it
                cookieGroup.rotation.x = Math.PI / 12; // Tilt slightly
                return cookieGroup;
            }

            // NEW: Function to create a 3D revolver ("Blicky") model
            function createBlickyModel() {
                const blickyGroup = new THREE.Group();
                
                // Materials
                const metalMat = new THREE.MeshStandardMaterial({
                    color: 0x808080, // Grey metal
                    roughness: 0.4,
                    metalness: 0.8
                });
                const gripMat = new THREE.MeshStandardMaterial({
                    color: 0x8B4513, // Brown
                    roughness: 0.7
                });

                // 1. Barrel
                const barrelGeo = new THREE.CylinderGeometry(0.1, 0.1, 1.5, 16);
                const barrel = new THREE.Mesh(barrelGeo, metalMat);
                barrel.rotation.x = Math.PI / 2; // Lie flat
                barrel.position.set(0, 0.2, 0.75); // Forward
                blickyGroup.add(barrel);
                
                // NEW: Front Sight
                const sightGeo = new THREE.BoxGeometry(0.05, 0.1, 0.05);
                const sight = new THREE.Mesh(sightGeo, metalMat);
                sight.position.set(0, 0.3, 1.45); // On top of the barrel, at the end
                blickyGroup.add(sight);


                // 2. Cylinder (rotating part)
                const cylinderGeo = new THREE.CylinderGeometry(0.4, 0.4, 0.8, 6); // 6 sides for hex look
                const cylinder = new THREE.Mesh(cylinderGeo, metalMat);
                cylinder.rotation.x = Math.PI / 2; // Lie flat
                cylinder.position.z = -0.2; // Behind barrel
                blickyGroup.add(cylinder);

                // 3. Frame (simple box)
                const frameGeo = new THREE.BoxGeometry(0.3, 0.5, 0.8);
                const frame = new THREE.Mesh(frameGeo, metalMat);
                frame.position.z = -0.2; // Aligned with cylinder
                blickyGroup.add(frame);
                
                // 4. Grip (Handle) - Shortened slightly
                const gripGeo = new THREE.BoxGeometry(0.3, 1.0, 0.4); // Was 1.2
                const grip = new THREE.Mesh(gripGeo, gripMat);
                grip.position.y = -0.5; // Moved up (was -0.6)
                grip.position.z = -0.7; // Tucked in (was -0.8)
                grip.rotation.z = Math.PI / 16; // Less angle (was / 12)
                blickyGroup.add(grip);
                
                // 5. Trigger - Made slightly thinner and taller
                const triggerGeo = new THREE.BoxGeometry(0.03, 0.25, 0.1); // Was 0.05, 0.2
                const trigger = new THREE.Mesh(triggerGeo, metalMat);
                trigger.position.y = -0.3;
                trigger.position.z = 0.2; // In front of grip, under frame
                blickyGroup.add(trigger);
                
                // NEW: Trigger Guard (using a Torus)
                const guardGeo = new THREE.TorusGeometry(0.25, 0.03, 8, 16, Math.PI); // Half-torus
                const guard = new THREE.Mesh(guardGeo, metalMat);
                guard.position.y = -0.25; // Below frame
                guard.position.z = 0.2; // Aligned with trigger
                guard.rotation.y = Math.PI / 2; // Rotate to face forward
                blickyGroup.add(guard);

                
                // 6. Hammer - Reshaped slightly
                const hammerGeo = new THREE.BoxGeometry(0.1, 0.2, 0.1);
                const hammer = new THREE.Mesh(hammerGeo, metalMat);
                hammer.position.y = 0.4; // Top of frame
                hammer.position.z = -0.5; // Back of frame
                blickyGroup.add(hammer);
                
                // NEW: Hammer Spur
                const spurGeo = new THREE.BoxGeometry(0.1, 0.1, 0.1);
                const spur = new THREE.Mesh(spurGeo, metalMat);
                spur.position.set(0, 0.5, -0.55); // Top-back of hammer
                spur.rotation.z = -Math.PI / 6; // Angled back
                blickyGroup.add(spur);

                
                // Scale and orient the whole model
                blickyGroup.scale.set(1.5, 1.5, 1.5); // Make it a bit bigger
                blickyGroup.rotation.y = Math.PI / 2; // Face sideways
                blickyGroup.position.y = 0.2; // Center it

                return blickyGroup;
            }

            // NEW: Function to create a 3D grandma model
            function createGrandmaModel() {
                const grandmaGroup = new THREE.Group();

                // Materials
                const skinMat = new THREE.MeshStandardMaterial({ color: 0xFDE5C3, roughness: 0.8 });
                const hairMat = new THREE.MeshStandardMaterial({ color: 0xC0C0C0, roughness: 0.7 }); // Silver grey
                const dressMat = new THREE.MeshStandardMaterial({ color: 0xFFC0CB, roughness: 0.8 }); // Pink
                const apronMat = new THREE.MeshStandardMaterial({ color: 0xFFFFFF, roughness: 0.9 });
                const woodMat = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.8 }); // Brown
                const eyeMat = new THREE.MeshStandardMaterial({ color: 0x000000, roughness: 0.1 });
                const glassesMat = new THREE.MeshStandardMaterial({ color: 0x000000, roughness: 0.1 }); // Black for glasses

                // Body (Dress)
                const bodyGeo = new THREE.CylinderGeometry(0.5, 0.8, 1.5, 16); // Tapered cone
                const body = new THREE.Mesh(bodyGeo, dressMat);
                body.position.y = 0;
                grandmaGroup.add(body);

                // Head (Sphere)
                const headGeo = new THREE.SphereGeometry(0.6, 32, 32);
                const head = new THREE.Mesh(headGeo, skinMat);
                head.position.y = 1.2;
                grandmaGroup.add(head);

                // Hair Bun
                const bunGeo = new THREE.SphereGeometry(0.3, 16, 16);
                const bun = new THREE.Mesh(bunGeo, hairMat);
                bun.position.y = 1.5; // On top of head
                bun.position.z = -0.3; // Further back
                grandmaGroup.add(bun);
                
                // Hair Cap (a slightly larger, squashed hemisphere)
                const hairCapGeo = new THREE.SphereGeometry(0.62, 32, 32, 0, Math.PI * 2, 0, Math.PI / 2); // Hemisphere
                const hairCap = new THREE.Mesh(hairCapGeo, hairMat);
                hairCap.position.y = 1.2; // Same as head center
                hairCap.rotation.x = -Math.PI / 2; // Rotate to sit on top-back
                hairCap.position.z = -0.1; // Shift back
                hairCap.scale.y = 0.5; // Squash it
                grandmaGroup.add(hairCap);

                
                // Eyes
                const eyeGeo = new THREE.SphereGeometry(0.05, 8, 8);
                const eyeLeft = new THREE.Mesh(eyeGeo, eyeMat);
                eyeLeft.position.set(-0.2, 1.3, 0.5);
                grandmaGroup.add(eyeLeft);
                
                const eyeRight = new THREE.Mesh(eyeGeo, eyeMat);
                eyeRight.position.set(0.2, 1.3, 0.5);
                grandmaGroup.add(eyeRight);

                // NEW: Glasses
                // Left Lens (Torus)
                const lensGeo = new THREE.TorusGeometry(0.12, 0.03, 8, 16);
                const lensLeft = new THREE.Mesh(lensGeo, glassesMat);
                lensLeft.position.set(-0.2, 1.3, 0.55); // Just in front of eye
                grandmaGroup.add(lensLeft);
                
                // Right Lens (Torus)
                const lensRight = new THREE.Mesh(lensGeo, glassesMat);
                lensRight.position.set(0.2, 1.3, 0.55); // Just in front of eye
                grandmaGroup.add(lensRight);
                
                // Bridge (Box)
                const bridgeGeo = new THREE.BoxGeometry(0.15, 0.03, 0.03);
                const bridge = new THREE.Mesh(bridgeGeo, glassesMat);
                bridge.position.set(0, 1.3, 0.55); // Between lenses
                grandmaGroup.add(bridge);
                
                // NEW: Nose
                const noseGeo = new THREE.SphereGeometry(0.1, 8, 8);
                const nose = new THREE.Mesh(noseGeo, skinMat);
                nose.position.set(0, 1.15, 0.6); // Below eyes, front of face
                grandmaGroup.add(nose);

                // Apron
                const apronGeo = new THREE.BoxGeometry(0.7, 0.8, 0.1);
                const apron = new THREE.Mesh(apronGeo, apronMat);
                apron.position.y = 0;
                apron.position.z = 0.6; // On front of dress
                grandmaGroup.add(apron);
                
                // Rolling Pin
                const pinGeo = new THREE.CylinderGeometry(0.08, 0.08, 1.2, 8);
                const pin = new THREE.Mesh(pinGeo, woodMat);
                // pin.rotation.x = Math.PI / 2; // REMOVED: No longer held flat
                pin.position.set(0.8, 0.2, 0.2); // MOVED: To her side
                pin.rotation.z = -Math.PI / 12; // Tilted slightly
                grandmaGroup.add(pin);

                // Scale and position
                grandmaGroup.scale.set(1.5, 1.5, 1.5);
                grandmaGroup.position.y = -0.5; // Center vertically

                return grandmaGroup;
            }

            // NEW: Function to create a 3D Grapes model
            function createGrapesModel() {
                const grapesGroup = new THREE.Group();
                
                const grapeMat = new THREE.MeshStandardMaterial({
                    color: 0x6A0DAD, // Purple
                    roughness: 0.6,
                    metalness: 0.1
                });
                
                const stemMat = new THREE.MeshStandardMaterial({
                    color: 0x5C3317, // Brown
                    roughness: 0.8
                });

                const grapeGeo = new THREE.SphereGeometry(0.2, 16, 16); // Small sphere for one grape

                // Create a bunch
                const positions = [
                    {x: 0, y: 0, z: 0},
                    {x: 0.3, y: -0.1, z: 0},
                    {x: -0.3, y: -0.1, z: 0},
                    {x: 0, y: -0.1, z: 0.3},
                    {x: 0, y: -0.1, z: -0.3},
                    {x: 0.15, y: -0.4, z: 0.15},
                    {x: -0.15, y: -0.4, z: -0.15},
                    {x: 0.15, y: -0.4, z: -0.15},
                    {x: -0.15, y: -0.4, z: 0.15},
                    {x: 0, y: -0.7, z: 0},
                    {x: 0.2, y: -0.7, z: 0.2},
                    {x: -0.2, y: -0.7, z: -0.2},
                    {x: 0, y: -1.0, z: 0.1}
                ];

                for (const pos of positions) {
                    const grape = new THREE.Mesh(grapeGeo, grapeMat);
                    grape.position.set(pos.x, pos.y, pos.z);
                    grapesGroup.add(grape);
                }
                
                // Add a stem
                const stemGeo = new THREE.CylinderGeometry(0.05, 0.1, 0.5, 8);
                const stem = new THREE.Mesh(stemGeo, stemMat);
                stem.position.y = 0.3; // At the top of the bunch
                grapesGroup.add(stem);

                grapesGroup.scale.set(1.8, 1.8, 1.8);
                grapesGroup.position.y = 0.5; // Lift the bunch up

                return grapesGroup;
            }

            function createPlaceholderModel() {
                const geometry = new THREE.BoxGeometry(2, 2, 2);
                const material = new THREE.MeshStandardMaterial({ 
                    color: 0x888888,
                    wireframe: true
                });
                const box = new THREE.Mesh(geometry, material);
                return box;
            }

            // NEW: Function to create a cute bakery model with lawn, flowers, and awning
            function createBakeryModel() {
                const bakeryGroup = new THREE.Group();

                // Main building
                const buildingGeo = new THREE.BoxGeometry(2.5, 2, 2.5);
                const buildingMat = new THREE.MeshStandardMaterial({
                    color: 0xFFC0CB, // Pink
                    roughness: 0.8
                });
                const building = new THREE.Mesh(buildingGeo, buildingMat);
                building.position.y = 0;
                bakeryGroup.add(building);

                // Roof
                const roofGeo = new THREE.ConeGeometry(2, 1.5, 4); // 4 sides for a pyramid roof
                const roofMat = new THREE.MeshStandardMaterial({
                    color: 0x8B4513, // Brown
                    roughness: 0.8
                });
                const roof = new THREE.Mesh(roofGeo, roofMat);
                roof.position.y = 1 + 0.75; // Position on top of the building
                roof.rotation.y = Math.PI / 4; // Align roof edges with building faces
                bakeryGroup.add(roof);

                // Door
                const doorGeo = new THREE.BoxGeometry(0.6, 1, 0.1);
                const doorMat = new THREE.MeshStandardMaterial({ color: 0x654321 }); // Darker brown
                const door = new THREE.Mesh(doorGeo, doorMat);
                door.position.set(0, -0.5, 1.26); // Front of the building
                bakeryGroup.add(door);

                // Window
                const windowGeo = new THREE.BoxGeometry(0.7, 0.7, 0.1);
                const windowMat = new THREE.MeshStandardMaterial({ 
                    color: 0xADD8E6, // Light blue
                    roughness: 0.3,
                    transparent: true,
                    opacity: 0.7
                });
                const windowMesh = new THREE.Mesh(windowGeo, windowMat);
                windowMesh.position.set(0, 0.3, 1.26); // Above the door
                bakeryGroup.add(windowMesh);

                // Sign (donut)
                const signGeo = new THREE.TorusGeometry(0.3, 0.1, 8, 16);
                const signMat = new THREE.MeshStandardMaterial({ color: 0xFFD700 }); // Gold
                const sign = new THREE.Mesh(signGeo, signMat);
                sign.position.set(0, 1.5, 1.4);
                sign.rotation.y = Math.PI / 2;
                bakeryGroup.add(sign);

                // --- NEW: Grass Lawn ---
                const lawnGeo = new THREE.BoxGeometry(4, 0.1, 4); // Wider, flatter box
                const lawnMat = new THREE.MeshStandardMaterial({ color: 0x6B8E23 }); // Olive green
                const lawn = new THREE.Mesh(lawnGeo, lawnMat);
                lawn.position.y = -1.05; // Below the building
                bakeryGroup.add(lawn);

                // --- NEW: Flowers ---
                const flowerColors = [0xFFC0CB, 0xFFFF00, 0x90EE90, 0xADD8E6];
                const stemMat = new THREE.MeshStandardMaterial({ color: 0x228B22 }); // Forest green
                const petalMat = new THREE.MeshStandardMaterial({ color: 0xFFD700 }); // Yellow center for all

                for (let i = 0; i < 8; i++) { // 8 flowers
                    const flowerGroup = new THREE.Group();

                    // Stem
                    const stemGeo = new THREE.CylinderGeometry(0.02, 0.02, 0.3, 8);
                    const stem = new THREE.Mesh(stemGeo, stemMat);
                    stem.position.y = 0.15;
                    flowerGroup.add(stem);

                    // Center (Disk)
                    const centerGeo = new THREE.CircleGeometry(0.08, 16);
                    const center = new THREE.Mesh(centerGeo, petalMat);
                    center.position.y = 0.3;
                    center.rotation.x = -Math.PI / 2;
                    flowerGroup.add(center);

                    // Petals
                    const petalGeo = new THREE.CircleGeometry(0.05, 8);
                    const petalColor = flowerColors[Math.floor(Math.random() * flowerColors.length)];
                    const currentPetalMat = new THREE.MeshStandardMaterial({ color: petalColor });
                    for (let p = 0; p < 6; p++) {
                        const petal = new THREE.Mesh(petalGeo, currentPetalMat);
                        petal.position.y = 0.3;
                        petal.position.x = Math.cos(p * Math.PI / 3) * 0.1;
                        petal.position.z = Math.sin(p * Math.PI / 3) * 0.1;
                        petal.rotation.x = -Math.PI / 2;
                        flowerGroup.add(petal);
                    }

                    // Random position on lawn
                    const x = (Math.random() - 0.5) * 3;
                    const z = (Math.random() - 0.5) * 3;
                    flowerGroup.position.set(x, -0.9, z);
                    bakeryGroup.add(flowerGroup);
                }

                // --- NEW: Awning with Donut ---
                const awningGroup = new THREE.Group();
                // Awning base (flat box)
                const awningBaseGeo = new THREE.BoxGeometry(2.8, 0.2, 1);
                const awningBaseMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 }); // Brown
                const awningBase = new THREE.Mesh(awningBaseGeo, awningBaseMat);
                awningBase.position.set(0, 1.1, 1.25);
                awningGroup.add(awningBase);

                // Striped awning fabric (simple boxes for now)
                const stripeMat1 = new THREE.MeshStandardMaterial({ color: 0xFFDDE1 }); // Light pink
                const stripeMat2 = new THREE.MeshStandardMaterial({ color: 0xE75480 }); // Dark pink

                for (let j = 0; j < 6; j++) {
                    const stripeGeo = new THREE.BoxGeometry(0.4, 0.1, 0.9);
                    const stripeMesh = new THREE.Mesh(stripeGeo, j % 2 === 0 ? stripeMat1 : stripeMat2);
                    stripeMesh.position.set(-1.2 + j * 0.45, 1.0, 1.25 + 0.45); // Position below base, pushed out
                    stripeMesh.rotation.x = Math.PI / 6; // Angle downwards
                    awningGroup.add(stripeMesh);
                }

                // Donut on the awning
                const awningDonutGeo = new THREE.TorusGeometry(0.2, 0.08, 8, 16);
                const awningDonutMat = new THREE.MeshStandardMaterial({ color: 0x5C3317 }); // Donut base color
                const awningDonut = new THREE.Mesh(awningDonutGeo, awningDonutMat);
                awningDonut.position.set(0, 1.4, 1.8); // Position above awning, slightly forward
                awningDonut.rotation.x = Math.PI / 2; // Lie flat
                awningDonut.rotation.y = Math.PI / 4; // Slight tilt

                // Glaze for awning donut
                const awningDonutGlazeGeo = new THREE.TorusGeometry(0.2, 0.085, 8, 16);
                const awningDonutGlazeMat = new THREE.MeshStandardMaterial({
                    color: 0xFFC0CB, // Pink glaze
                    transparent: true,
                    opacity: 0.9
                });
                const awningDonutGlaze = new THREE.Mesh(awningDonutGlazeGeo, awningDonutGlazeMat);
                awningDonutGlaze.position.set(0, 1.4, 1.8);
                awningDonutGlaze.rotation.x = Math.PI / 2;
                awningDonutGlaze.rotation.y = Math.PI / 4;
                awningGroup.add(awningDonut);
                awningGroup.add(awningDonutGlaze);

                bakeryGroup.add(awningGroup);


                bakeryGroup.scale.set(0.8, 0.8, 0.8); // Scale it down a bit
                bakeryGroup.position.y = -0.5; // Center it vertically

                return bakeryGroup;
            }

            // NEW: Function to create a simple powdered donut model
            function createPowderedDonutModel() {
                const donutGroup = new THREE.Group();

                // 1. Donut Base (same as Glazery donut)
                const donutGeometry = new THREE.TorusGeometry(2.8, 1.3, 32, 100);

                // Use existing texture functions
                const crackTexture = createCrackTexture(1024);
                crackTexture.wrapS = crackTexture.wrapT = THREE.RepeatWrapping;
                crackTexture.repeat.set(1, 1);
                
                const speckleTexture = createSpeckleTexture(512);
                speckleTexture.wrapS = speckleTexture.wrapT = THREE.RepeatWrapping;
                speckleTexture.repeat.set(3, 3);

                const donutMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xD2B48C, // CHANGED: Was 0x5C3317 (Dark brown), now light tan
                    roughness: 0.8,
                    metalness: 0.05,
                    map: speckleTexture,
                    bumpMap: crackTexture,
                    bumpScale: 0.08
                });
                const donutBase = new THREE.Mesh(donutGeometry, donutMaterial);
                donutGroup.add(donutBase);

                // 2. Powder Layer
                const powderTexture = createPowderTexture(512);
                powderTexture.wrapS = THREE.RepeatWrapping;
                powderTexture.wrapT = THREE.RepeatWrapping;
                powderTexture.repeat.set(2, 2); // Repeat the texture

                const powderGeometry = new THREE.TorusGeometry(2.8, 1.35, 32, 100); // Slightly larger
                const powderMaterial = new THREE.MeshStandardMaterial({ // CHANGED: Was Lambert
                    color: 0xFFFFFF, // White
                    roughness: 0.9, // Very rough, not shiny
                    metalness: 0.0,
                    transparent: true,
                    alphaMap: powderTexture, // Use texture for transparency
                    opacity: 1.0 // CHANGED: Was 0.9, now fully opaque where texture is white
                });

                const powderMesh = new THREE.Mesh(powderGeometry, powderMaterial);
                donutGroup.add(powderMesh);
                
                // Scale and center it
                donutGroup.scale.set(0.8, 0.8, 0.8); // Scale it down to fit
                donutGroup.position.y = 0; // Center it

                return donutGroup;
            }


            function initThreeJS() {
                if (isThreeJSInitialized) return; 
                
                scene = new THREE.Scene();
                
                const container = dom.glazery.rainContainer; // Renamed: miner -> glazery
                if (!container) return; // Add check
                const w = container.clientWidth || 300;
                const h = container.clientHeight || 300;

                camera = new THREE.PerspectiveCamera(75, w / h, 0.1, 1000);
                camera.position.z = currentCameraZ;

                if (!dom.glazery.canvas) return; // Add check
                renderer = new THREE.WebGLRenderer({ 
                    canvas: dom.glazery.canvas, // Renamed: miner -> glazery
                    alpha: true
                });
                renderer.setSize(w, h);
                renderer.setPixelRatio(window.devicePixelRatio);

                const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
                scene.add(ambientLight);
                // Increased directional light slightly
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7); 
                directionalLight.position.set(5, 5, 5);
                scene.add(directionalLight);

                donutGroup = new THREE.Group();
                
                // Donut Base
                const donutGeometry = new THREE.TorusGeometry(
                    2.8, // Decreased main radius
                    1.3, // Increased tube radius
                    32,
                    100
                );

                // Create textures
                const crackTexture = createCrackTexture(1024);
                crackTexture.wrapS = crackTexture.wrapT = THREE.RepeatWrapping;
                crackTexture.repeat.set(1, 1); // Reduced repeat for larger cracks
                
                const speckleTexture = createSpeckleTexture(512);
                speckleTexture.wrapS = speckleTexture.wrapT = THREE.RepeatWrapping;
                speckleTexture.repeat.set(3, 3); // Reduced repeat for larger speckles

                const donutMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x5C3317, // Dark brown - Base color
                    roughness: 0.8,
                    metalness: 0.05,
                    map: speckleTexture, // Apply speckle as main color texture
                    bumpMap: crackTexture, // Apply cracks as bump map for depth
                    bumpScale: 0.08 // Increased bump scale
                });
                const donutBase = new THREE.Mesh(donutGeometry, donutMaterial);
                donutGroup.add(donutBase);

                // ===============================================================
                // Glaze Layer with Irregular Scalloping
                // ===============================================================
                const glazeRadius = 2.75; 
                const glazeTubeRadius = 1.35; 
                const radialSegments = 32; 
                const tubularSegments = 100;

                const glazeGeometry = new THREE.TorusGeometry(
                    glazeRadius,
                    glazeTubeRadius,
                    radialSegments,
                    tubularSegments
                );
                
                const positionAttribute = glazeGeometry.attributes.position;
                const tempVector = new THREE.Vector3();

                // Generate random offsets for an irregular edge
                const irregularityFactor = 0.15; 
                const randomOffsets = new Array(tubularSegments).fill(0).map(() => Math.random() * irregularityFactor * 2 - irregularityFactor);


                for (let i = 0; i < positionAttribute.count; i++) {
                    tempVector.fromBufferAttribute(positionAttribute, i);

                    const x = tempVector.x;
                    const y = tempVector.y;
                    const z = tempVector.z;

                    const r = Math.sqrt(x * x + y * y);
                    const angleAroundDonut = Math.atan2(y, x); 
                    
                    const distFromCenterOfTorus = Math.sqrt(x * x + y * y + z * z);
                    const distFromGlazeMainRadius = Math.abs(r - glazeRadius);

                    const isOuterEdge = distFromGlazeMainRadius < (glazeTubeRadius * 0.4) && r > glazeRadius; 
                    const isBottomHalf = z < -0.4 * glazeTubeRadius; 

                    const isInnerEdge = distFromGlazeMainRadius < (glazeTubeRadius * 0.4) && r < glazeRadius;

                    if (isOuterEdge && isBottomHalf) {
                        const segmentIndex = Math.floor((angleAroundDonut / (2 * Math.PI)) * tubularSegments + tubularSegments) % tubularSegments;
                        const scallopMagnitude = 0.1 + (randomOffsets[segmentIndex] * 0.8 + 0.5) * 0.1; 
                        
                        const currentRadius = Math.sqrt(tempVector.x * tempVector.x + tempVector.y * tempVector.y);
                        const normalizedX = tempVector.x / currentRadius;
                        const normalizedY = tempVector.y / currentRadius;

                        tempVector.x += normalizedX * scallopMagnitude;
                        tempVector.y += normalizedY * scallopMagnitude;
                        tempVector.z += scallopMagnitude * 0.5; 

                        positionAttribute.setXYZ(i, tempVector.x, tempVector.y, tempVector.z);
                    } else if (isInnerEdge) {
                        if (tempVector.z < -0.1) { 
                           tempVector.z = Math.min(tempVector.z + 0.1, 0); 
                        }
                        positionAttribute.setXYZ(i, tempVector.x, tempVector.y, tempVector.z);
                    }
                }

                glazeGeometry.attributes.position.needsUpdate = true;
                glazeGeometry.computeVertexNormals(); 

                glazeMaterial = new THREE.MeshStandardMaterial({ // Make glazeMaterial globally accessible
                    color: glazeColors[currentGlazeColorIndex], // Use initial color
                    roughness: 0.2,  
                    metalness: 0.1,  
                    transparent: true,
                    opacity: 0.85    
                });
                const glaze = new THREE.Mesh(glazeGeometry, glazeMaterial);
                glaze.position.z = 0.05; 
                donutGroup.add(glaze);

                // ===============================================================
                // Sprinkles
                // ===============================================================
                const sprinkleColors = [
                    0xFF0000, 0xFF7F00, 0xFFFF00, 0x00FF00, 0x0000FF, 0x4B0082, 0x9400D3 
                ];
                const sprinkleShape = new THREE.CylinderGeometry(0.06, 0.06, 0.4, 8); 
                
                const numSprinkles = 800; 
                const R_sprinkle = 2.8; 
                const r_sprinkle = 1.3 * 0.9; 

                for (let i = 0; i < numSprinkles; i++) {
                    const color = sprinkleColors[Math.floor(Math.random() * sprinkleColors.length)];
                    const sprinkleMaterial = new THREE.MeshStandardMaterial({ color: color });
                    const sprinkle = new THREE.Mesh(sprinkleShape, sprinkleMaterial);

                    const u = Math.random() * 2 * Math.PI; 
                    const v = Math.random() * 2 * Math.PI; 
                    
                    sprinkle.position.x = (R_sprinkle + r_sprinkle * Math.cos(u)) * Math.cos(v);
                    sprinkle.position.y = (R_sprinkle + r_sprinkle * Math.cos(u)) * Math.sin(v);
                    sprinkle.position.z = r_sprinkle * Math.sin(u);

                    if (sprinkle.position.z < -0.2 * 1.3) { 
                        continue; 
                    }

                    const centerOfTubeCrossSection = new THREE.Vector3(R_sprinkle * Math.cos(v), R_sprinkle * Math.sin(v), 0);
                    const normal = new THREE.Vector3().subVectors(sprinkle.position, centerOfTubeCrossSection).normalize();
                    sprinkle.position.addScaledVector(normal, 0.12); 

                    sprinkle.lookAt(new THREE.Vector3().addVectors(sprinkle.position, normal));
                    sprinkle.rotateX(Math.PI / 2); 
                    
                    sprinkle.rotation.z += Math.random() * Math.PI; 

                    donutGroup.add(sprinkle);
                }
                
                
                scene.add(donutGroup);

                // Add pointer listeners for Glazery
                dom.glazery.canvas.addEventListener('pointerdown', onPointerDown); // Renamed: miner -> glazery
                dom.glazery.canvas.addEventListener('pointermove', onPointerMove); // Renamed: miner -> glazery
                dom.glazery.canvas.addEventListener('pointerup', onPointerUp); // Renamed: miner -> glazery
                dom.glazery.canvas.addEventListener('pointerleave', onPointerUp); // Renamed: miner -> glazery
                dom.glazery.canvas.addEventListener('wheel', onMouseWheel, { passive: false }); // Renamed: miner -> glazery

                // Start the *single* animation loop
                // animate(); // REMOVED FROM HERE
                
                // NEW: Setup zoom slider
                dom.glazery.zoomSlider.min = MIN_ZOOM_Z;
                dom.glazery.zoomSlider.max = MAX_ZOOM_Z;
                dom.glazery.zoomSlider.value = currentCameraZ;
                dom.glazery.zoomSlider.step = 0.1; // For smooth sliding

                isThreeJSInitialized = true; 
            }

            // --- Init Bakery 3D ---
            function initBakeryThreeJS() {
                if (isBakeryThreeJSInitialized) return;

                bakeryScene = new THREE.Scene();
                
                const container = dom.bakeryPage.container;
                if (!container) return; // Add check
                const w = container.clientWidth || 300;
                const h = container.clientHeight || 160; // MODIFIED: 192px (h-48) to 160px (h-40)

                bakeryCamera = new THREE.PerspectiveCamera(75, w / h, 0.1, 1000);
                bakeryCamera.position.z = bakeryCurrentCameraZ;

                if (!dom.bakeryPage.canvas) return; // Add check
                bakeryRenderer = new THREE.WebGLRenderer({ 
                    canvas: dom.bakeryPage.canvas,
                    alpha: true
                });
                bakeryRenderer.setSize(w, h);
                bakeryRenderer.setPixelRatio(window.devicePixelRatio);

                const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
                bakeryScene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7); 
                directionalLight.position.set(5, 5, 5);
                bakeryScene.add(directionalLight);

                bakeryItemGroup = new THREE.Group();
                bakeryScene.add(bakeryItemGroup);

                // REMOVED: No longer adding a placeholder by default
                // bakeryItemGroup.add(createPlaceholderModel());
                
                // NEW: Add bakery building model (initially hidden)
                bakeryBuildingModelGroup = new THREE.Group();
                bakeryBuildingModelGroup.add(createPowderedDonutModel()); // CHANGED from createBakeryModel()
                bakeryBuildingModelGroup.visible = false;
                bakeryScene.add(bakeryBuildingModelGroup);

                // Add pointer listeners for Bakery
                dom.bakeryPage.canvas.addEventListener('pointerdown', onBakeryPointerDown);
                dom.bakeryPage.canvas.addEventListener('pointermove', onBakeryPointerMove);
                dom.bakeryPage.canvas.addEventListener('pointerup', onBakeryPointerUp);
                dom.bakeryPage.canvas.addEventListener('pointerleave', onBakeryPointerUp);
                dom.bakeryPage.canvas.addEventListener('wheel', onBakeryMouseWheel, { passive: false });

                // NEW: Setup zoom slider
                dom.bakeryPage.zoomSlider.min = BAKERY_MIN_ZOOM_Z;
                dom.bakeryPage.zoomSlider.max = BAKERY_MAX_ZOOM_Z;
                dom.bakeryPage.zoomSlider.value = bakeryCurrentCameraZ;
                dom.bakeryPage.zoomSlider.step = 0.1; // For smooth sliding

                isBakeryThreeJSInitialized = true; // FIX: Was isThreeJSInitialized
            }

            // ===============================================================
            // 3D BAKERY SETUP (NEW)
            // ===============================================================
            let bakeryScene, bakeryCamera, bakeryRenderer, bakeryItemGroup, bakeryBuildingModelGroup;
            let bakeryIsDragging = false;
            let bakeryPreviousPointerX = 0;
            let bakeryPreviousPointerY = 0;
            let bakeryCurrentCameraZ = 5; // Closer zoom for items
            let isBakeryThreeJSInitialized = false;

            const BAKERY_MIN_ZOOM_Z = 2;
            const BAKERY_MAX_ZOOM_Z = 10;

            // --- Model Creation Functions ---
            // DELETED all model functions from here
            // ===============================================================
            // UNIVERSAL 3D CONTROLS & ANIMATION
            // ===============================================================

            // --- Resize (handles both canvases) ---
            function onResize() {
                // Resize Glazery Canvas
                if (renderer && camera && dom.glazery.rainContainer) {
                    const container = dom.glazery.rainContainer;
                    const w = container.clientWidth;
                    const h = container.clientHeight;
                    if (w > 0 && h > 0) {
                        camera.aspect = w / h;
                        camera.updateProjectionMatrix();
                        renderer.setSize(w, h);
                    }
                }
                
                // Resize Bakery Canvas
                if (bakeryRenderer && bakeryCamera && dom.bakeryPage.container) {
                    const container = dom.bakeryPage.container;
                    const w = container.clientWidth;
                    const h = container.clientHeight;
                    if (w > 0 && h > 0) {
                        bakeryCamera.aspect = w / h;
                        bakeryCamera.updateProjectionMatrix();
                        bakeryRenderer.setSize(w, h);
                    }
                }
            }
            window.addEventListener('resize', onResize); // Add listener once

            // --- Single Animation Loop (handles both scenes) ---
            function animate() {
                requestAnimationFrame(animate);
                
                // Render Glazery if active
                if (state.ui.activeView === 'glazery' && donutGroup && renderer) {
                    if (!isDragging) { 
                        donutGroup.rotation.y += 0.005; 
                    }
                    renderer.render(scene, camera);
                }
                
                // Render Bakery if active
                // MODIFIED: Added check for bakeryBuildingModelGroup to prevent race condition
                if (state.ui.activeView === 'bakery' && bakeryItemGroup && bakeryBuildingModelGroup && bakeryRenderer) {
                    if (!bakeryIsDragging) {
                        if (bakeryItemGroup.visible) bakeryItemGroup.rotation.y += 0.005;
                        if (bakeryBuildingModelGroup.visible) bakeryBuildingModelGroup.rotation.y -= 0.005; // Rotate other way
                    }
                    bakeryRenderer.render(bakeryScene, bakeryCamera);
                }
            }

            // --- Glazery (Donut) Pointer Events ---
            let pointers = [];

            function getPinchDistance(e) {
                if (e.touches && e.touches.length === 2) {
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    return Math.sqrt(dx * dx + dy * dy);
                }
                return 0;
            }

            function onPointerDown(e) {
                pointers.push(e);
                if (pointers.length === 1) {
                    isDragging = true;
                    previousPointerX = e.clientX;
                    previousPointerY = e.clientY;
                } else if (pointers.length === 2) {
                    isDragging = false;
                    initialPinchDistance = getPinchDistance(e);
                }
                dom.glazery.canvas.setPointerCapture(e.pointerId); // Renamed: miner -> glazery
            }

            function onPointerMove(e) {
                const index = pointers.findIndex(p => p.pointerId === e.pointerId);
                if (index > -1) {
                    pointers[index] = e;
                }

                if (pointers.length === 2 && initialPinchDistance > 0) {
                    const currentPinchDistance = getPinchDistance(e);
                    if (currentPinchDistance === 0) return;
                    
                    const zoomFactor = initialPinchDistance / currentPinchDistance;
                    let newZ = currentCameraZ * zoomFactor;
                    
                    newZ = Math.max(MIN_ZOOM_Z, Math.min(MAX_ZOOM_Z, newZ));
                    camera.position.z = newZ;
                    camera.updateProjectionMatrix();
                    dom.glazery.zoomSlider.value = newZ; // SYNC SLIDER

                    initialPinchDistance = currentPinchDistance;
                    currentCameraZ = newZ;

                } else if (isDragging && pointers.length === 1) {
                    const deltaX = e.clientX - previousPointerX;
                    const deltaY = e.clientY - previousPointerY;
                    
                    // Rotate around Y (left/right) and X (up/down)
                    donutGroup.rotation.y += deltaX * 0.01;
                    donutGroup.rotation.x += deltaY * 0.01;
                    
                    previousPointerX = e.clientX;
                    previousPointerY = e.clientY;
                }
            }

            function onPointerUp(e) {
                pointers = pointers.filter(p => p.pointerId !== e.pointerId);
                dom.glazery.canvas.releasePointerCapture(e.pointerId); // Renamed: miner -> glazery

                if (isDragging && pointers.length === 0) {
                    const deltaX = Math.abs(e.clientX - previousPointerX);
                    const deltaY = Math.abs(e.clientY - previousPointerY);

                    if(deltaX < 5 && deltaY < 5) {
                        // playSoundEffect('crunch'); // REMOVED: handleMinerAction will play its own sound
                        handleMinerAction(); // Renamed: handleBakeryAction -> handleMinerAction
                        
                        donutGroup.scale.set(1.1, 1.1, 1.1);
                        setTimeout(() => {
                            donutGroup.scale.set(1, 1, 1);
                        }, 100);
                    }
                    isDragging = false;
                }

                if (pointers.length < 2) {
                    initialPinchDistance = 0;
                }
            }

            function onMouseWheel(e) {
                e.preventDefault();
                let newZ = currentCameraZ + e.deltaY * 0.02;
                newZ = Math.max(MIN_ZOOM_Z, Math.min(MAX_ZOOM_Z, newZ));
                camera.position.z = newZ;
                camera.updateProjectionMatrix();
                dom.glazery.zoomSlider.value = newZ; // SYNC SLIDER
                currentCameraZ = newZ;
            }

            // --- Bakery (Item) Pointer Events (NEW) ---
            let bakeryPointers = [];
            
            function onBakeryPointerDown(e) {
                bakeryPointers.push(e);
                bakeryIsDragging = true;
                bakeryPreviousPointerX = e.clientX;
                bakeryPreviousPointerY = e.clientY;
                dom.bakeryPage.canvas.setPointerCapture(e.pointerId);
            }

            function onBakeryPointerMove(e) {
                const index = bakeryPointers.findIndex(p => p.pointerId === e.pointerId);
                if (index > -1) {
                    bakeryPointers[index] = e;
                }
                if (bakeryIsDragging && bakeryPointers.length === 1) {
                    const deltaX = e.clientX - bakeryPreviousPointerX;
                    const deltaY = e.clientY - bakeryPreviousPointerY;
                    bakeryItemGroup.rotation.y += deltaX * 0.01;
                    bakeryItemGroup.rotation.x += deltaY * 0.01;
                    bakeryPreviousPointerX = e.clientX;
                    bakeryPreviousPointerY = e.clientY;
                }
            }

            function onBakeryPointerUp(e) {
                bakeryPointers = bakeryPointers.filter(p => p.pointerId !== e.pointerId);
                dom.bakeryPage.canvas.releasePointerCapture(e.pointerId);
                if (bakeryPointers.length === 0) {
                    bakeryIsDragging = false;
                }
            }

            function onBakeryMouseWheel(e) {
                e.preventDefault();
                let newZ = bakeryCurrentCameraZ + e.deltaY * 0.02;
                newZ = Math.max(BAKERY_MIN_ZOOM_Z, Math.min(BAKERY_MAX_ZOOM_Z, newZ));
                bakeryCamera.position.z = newZ;
                bakeryCamera.updateProjectionMatrix();
                dom.bakeryPage.zoomSlider.value = newZ; // SYNC SLIDER
                bakeryCurrentCameraZ = newZ;
            }


            // Function to change glaze color
            function changeGlazeColor() {
                if (glazeMaterial) {
                    currentGlazeColorIndex = (currentGlazeColorIndex + 1) % glazeColors.length;
                    glazeMaterial.color.set(glazeColors[currentGlazeColorIndex]);
                }
            }


            // ===============================================================
            // RENDER/UPDATE FUNCTIONS
            // ===============================================================

            // NEW: Colors for items
            const ITEM_COLORS = [
                '#E75480', // Strong Pink (egg)
                '#ADD8E6', // Light Blue (milk)
                '#FF6347', // Tomato Red (cherries)
                '#D2691E', // Chocolate (bacon)
                '#8B4513', // Saddle Brown (cookie)
                '#FFD700', // Gold (cursor)
                '#90EE90', // Light Green (grandma)
                '#66CCBF', // Teal (farm)
                '#B0C4DE', // Light Steel Blue (mine)
                '#A9A9A9'  // Dark Gray (factory)
            ];

            // NEW: Function to render the power breakdown bar chart
            const renderPowerBarChart = () => {
                const barContainer = dom.bakeryPage.powerBar;
                const legendContainer = dom.bakeryPage.powerBarLegend;
                barContainer.innerHTML = '';
                legendContainer.innerHTML = '';

                let totalPower = 0;
                const powerBreakdown = [];
                let colorIndex = 0;

                for (const name in state.player.items) {
                    const def = state.items[name];
                    const count = state.player.items[name];
                    const itemPower = count * def.basePower;
                    
                    if (itemPower > 0) {
                        powerBreakdown.push({
                            name: def.name,
                            emoji: def.emoji,
                            power: itemPower,
                            color: ITEM_COLORS[colorIndex % ITEM_COLORS.length]
                        });
                        totalPower += itemPower;
                    }
                    colorIndex++;
                }

                if (totalPower === 0) {
                    const textColor = state.ui.isDarkMode ? 'text-gray-400' : 'text-gray-500';
                    legendContainer.innerHTML = `<div class="${textColor} text-center w-full">Buy items to see your power breakdown!</div>`;
                    barContainer.style.backgroundColor = state.ui.isDarkMode ? '#3D2B1F' : '#E5E7EB'; // Dark/light gray
                    return;
                }

                barContainer.style.backgroundColor = 'transparent'; // Reset bg

                // Create bars and legend items
                for (const item of powerBreakdown) {
                    const percentage = (item.power / totalPower) * 100;
                    
                    // Create Bar Segment
                    const barSegment = document.createElement('div');
                    barSegment.style.width = `${percentage}%`;
                    barSegment.style.backgroundColor = item.color;
                    barSegment.setAttribute('title', `${item.name}: ${item.power.toFixed(1)}‚ö° (${percentage.toFixed(1)}%)`); // Tooltip
                    barContainer.appendChild(barSegment);

                    // Create Legend Item
                    const legendItem = document.createElement('div');
                    legendItem.className = 'flex items-center space-x-1';
                    legendItem.innerHTML = `
                        <div class="w-2 h-2 rounded-full" style="background-color: ${item.color};"></div>
                        <span class="text-tamagotchi-dark">${item.emoji} ${item.name}</span>
                    `;
                    legendContainer.appendChild(legendItem);
                }
            };


            const renderBakery = () => { // Renamed: renderStore -> renderBakery
                const container = dom.bakeryPage.itemList; // Renamed: dom.store.buildingList -> dom.bakeryPage.itemList
                container.innerHTML = '';
                
                // Get total power once before the loop
                const totalPlayerPower = state.player.productionPower;

                for (const name in state.items) { // Renamed: buildings -> items
                    const def = state.items[name]; // Renamed: buildings -> items
                    const cost = getItemCost(name); // Renamed: getBuildingCost -> getItemCost
                    const canAfford = state.player.cookies >= cost;
                    const isSelected = state.ui.selectedItem === name; // Renamed: selectedBuilding -> selectedItem
                    
                    // --- NEW: Calculate percentage ---
                    const itemPower = state.player.items[name] * def.basePower;
                    const percentage = totalPlayerPower > 0 ? (itemPower / totalPlayerPower) * 100 : 0;
                    const percentageText = percentage > 0 ? `${percentage.toFixed(1)}%` : '0%';
                    // --- END NEW ---
                    
                    const el = document.createElement('div');
                    el.className = `store-item flex items-center justify-between p-2 bg-tamagotchi-card rounded-tamagotchi-md border border-tamagotchi-subtle shadow-tamagotchi ${isSelected ? 'selected' : ''}`;
                    el.dataset.item = name; // Renamed: building -> item
                    
                    el.innerHTML = `
                        <div class="flex items-center space-x-3">
                            <span class="text-3xl">${def.emoji}</span>
                            <div>
                                <div class="text-base font-bold text-tamagotchi-dark">${def.name}</div>
                                <div class="text-sm font-semibold ${canAfford ? 'text-tamagotchi-pink-dark' : 'text-red-500'}">
                                    üç© ${format(cost)}
                                </div>
                            </div>
                        </div>
                        <div class="text-right pr-2"> <!-- MODIFIED: Changed wrapper div to stack quantity and percentage -->
                            <div class="text-2xl font-extrabold text-tamagotchi-dark">${state.player.items[name]}</div>
                            <div class="text-xs font-semibold ${percentage > 0 ? 'text-tamagotchi-pink-dark' : 'text-gray-500'}">
                                ${percentageText}
                            </div>
                        </div>
                    `;
                    
                    el.onclick = () => {
                        playSoundEffect('crunch'); // NEW
                        selectItem(name); // Renamed: selectBuilding -> selectItem
                    }
                    container.appendChild(el);
                }
            };
            
            const renderBakeryItemInfo = () => { 
                const name = state.ui.selectedItem;
                const infoBox = dom.bakeryPage.itemInfoStats; // Target the stats div

                if (!name) {
                    infoBox.innerHTML = `
                        <div class="text-center text-gray-500 text-sm p-2">
                            Select an item from the list below to see its details.
                        </div>
                    `;
                    return;
                }

                const def = state.items[name];
                const cost = getItemCost(name); // Cost for next one
                const owned = state.player.items[name];

                infoBox.innerHTML = `
                    <div class="grid grid-cols-3 gap-2 text-center">
                        <div>
                            <div class="text-xs text-gray-500 font-semibold">Owned</div>
                            <div class="font-extrabold text-lg text-tamagotchi-dark">${format(owned)}</div>
                        </div>
                        <div>
                            <div class="text-xs text-gray-500 font-semibold">Next Price</div>
                            <div class="font-extrabold text-lg text-tamagotchi-pink-dark">üç© ${format(cost)}</div>
                        </div>
                        <div>
                            <div class="text-xs text-gray-500 font-semibold">Power</div>
                            <div class="font-extrabold text-lg text-tamagotchi-dark">‚ö° ${def.basePower}</div>
                        </div>
                    </div>
                `;
            };

            // NEW: Function to update the slider and purchase buttons
            const updatePurchaseControls = () => {
                const name = state.ui.selectedItem;
                const slider = dom.bakeryPage.slider;
                const amountLabel = dom.bakeryPage.amountLabel;
                const purchaseButton = dom.bakeryPage.purchaseButton;
                const upgradeButton = dom.bakeryPage.upgradeButton;
                const maxButton = dom.bakeryPage.maxButton;
                const prevButton = dom.bakeryPage.prevButton; // NEW
                const nextButton = dom.bakeryPage.nextButton; // NEW

                if (!name) {
                    slider.disabled = true;
                    slider.value = 1;
                    slider.max = 1;
                    amountLabel.textContent = "Amount: -";
                    purchaseButton.disabled = true;
                    purchaseButton.textContent = "Purchase";
                    upgradeButton.disabled = true;
                    maxButton.disabled = true;
                    prevButton.disabled = true; // NEW
                    nextButton.disabled = true; // NEW
                    return;
                }

                // An item is selected, enable controls
                slider.disabled = false;
                maxButton.disabled = false;
                upgradeButton.disabled = true; // Still disabled for now
                prevButton.disabled = false; // NEW
                nextButton.disabled = false; // NEW

                const maxAffordable = calculateMaxAffordable(name);
                slider.max = maxAffordable;
                // If slider value is somehow higher than new max, reset it
                if (parseInt(slider.value, 10) > maxAffordable) {
                    slider.value = maxAffordable;
                }
                
                const amount = parseInt(slider.value, 10);
                const totalCost = getBulkItemCost(name, amount);
                const canAfford = state.player.cookies >= totalCost;

                amountLabel.textContent = `Amount: ${amount}`;
                purchaseButton.disabled = !canAfford;
                purchaseButton.textContent = `Purchase (${format(totalCost)} D)`;
            };

            const updateUI = () => {
                const factoryPool = state.global.emissionRate * 0.8;
                
                // This is the player's share of the *factory pool* (a value from 0 to 1)
                const playerFactoryShare = state.global.totalProductionPower > 0 
                    ? state.player.productionPower / state.global.totalProductionPower 
                    : 0;
                
                const factoryCps = factoryPool * playerFactoryShare;

                const bakeryCps = state.player.isBakerKing ? (state.global.emissionRate * 0.2) : 0;

                // --- NEW LOGIC for Mining % Display ---
                
                // 1. Calculate the base mining percent. This is the player's share of the 80% factory pool.
                // (playerFactoryShare is 0.0 to 1.0, so this value is 0.0 to 80.0)
                let baseMiningPercent = playerFactoryShare * 80.0;
                
                // 2. Calculate the glazer bonus. This is a flat 20% of total emissions.
                let glazerMiningPercent = state.player.isBakerKing ? 20.0 : 0.0;

                // 3. The total mining percent is the sum, which will be between 0% and 100%.
                let displayMiningPercent = baseMiningPercent + glazerMiningPercent;
                
                // --- END NEW LOGIC ---
                
                // Update the text
                dom.bakeryPage.totalCookies.textContent = formatDecimal(displayMiningPercent);
                
                // Add/Remove the glow class from the *parent* div for better effect
                const miningShareContainer = dom.bakeryPage.totalCookies.parentElement; // This is the <div class="font-extrabold ...">
                if (state.player.isBakerKing) {
                    miningShareContainer.classList.add('text-glow-boosted');
                } else {
                    miningShareContainer.classList.remove('text-glow-boosted');
                }
                // --- END MODIFIED LOGIC ---

                dom.bakeryPage.globalCps.textContent = formatDecimal(state.global.emissionRate);
                dom.bakeryPage.miningPower.textContent = format(state.player.productionPower);
                dom.bakeryPage.donutBalance.textContent = format(state.player.cookies);

                dom.glazery.cps.textContent = formatDecimal(bakeryCps);
                
                // --- MODIFIED LOGIC for Glaze Time ---
                if (state.player.isBakerKing && state.player.glazeStartTime) {
                    const elapsedMs = Date.now() - state.player.glazeStartTime;
                    dom.glazery.baked.textContent = formatGlazeTime(elapsedMs); // CHANGED: from format()
                } else {
                    dom.glazery.baked.textContent = '00:00:00'; // CHANGED: from format()
                }
                // --- END MODIFIED LOGIC ---
                
                const claimableBakery = Math.floor(state.player.claimableBakeryCookies);
                if (state.player.isBakerKing) {
                    dom.glazery.kingStatus.textContent = 'You';
                    dom.glazery.actionButton.textContent = `Bake ${format(claimableBakery)}`;
                    dom.glazery.actionButton.disabled = claimableBakery < 1;
                } else {
                    dom.glazery.kingStatus.textContent = 'None';
                    dom.glazery.actionButton.textContent = 'Glaze';
                    dom.glazery.actionButton.disabled = false;
                }
                
                // NEW: Update About Page Stats
                if (state.ui.activeView === 'about') {
                    const { totalDonutSupply, totalCookiesCreated, nextHalvingAt, totalMiners } = state.global;
                    
                    dom.aboutPage.totalSupply.textContent = `üç© ${format(totalDonutSupply)}`;
                    
                    const percentMined = totalDonutSupply > 0 ? (totalCookiesCreated / totalDonutSupply) * 100 : 0;
                    dom.aboutPage.percentMined.textContent = `${formatDecimal(percentMined)}%`;

                    // Mock a countdown
                    const blocksRemaining = nextHalvingAt - totalCookiesCreated;
                    // Assuming 1 tick (100ms) = 1 "second" in game time for the countdown
                    const secondsRemaining = Math.max(0, Math.floor(blocksRemaining * (GAME_TICK_MS / 100))); 
                    const hours = Math.floor(secondsRemaining / 3600);
                    const minutes = Math.floor((secondsRemaining % 3600) / 60);
                    const seconds = secondsRemaining % 60;
                    dom.aboutPage.nextHalving.textContent = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;

                    dom.aboutPage.totalMiners.textContent = `üë§ ${format(totalMiners)}`;
                }
            };
            
            // NEW: Function to apply collapse state
            const applyBakeryCollapseState = () => {
                if (state.ui.isItemListCollapsed) {
                    // COLLAPSED VIEW
                    dom.bakeryPage.itemListContainer.classList.add('hidden');
                    dom.bakeryPage.itemListToggleIcon.classList.add('collapsed');
                    
                    // Show global stats
                    dom.bakeryPage.powerChartContainer.classList.remove('hidden');
                    renderPowerBarChart();
                    
                    // Deselect any item (which hides info box, ticker, and item model)
                    selectItem(null); 
                    
                } else {
                    // EXPANDED VIEW
                    dom.bakeryPage.itemListContainer.classList.remove('hidden');
                    dom.bakeryPage.itemListToggleIcon.classList.remove('collapsed');
                    
                    // Hide global stats
                    dom.bakeryPage.powerChartContainer.classList.add('hidden');
                    
                    // Deselect any item (which hides info box, ticker, and item model)
                    selectItem(null);
                }
            };

            const showView = (viewName) => {
                // Hide all views
                for (const key in dom.views) {
                    dom.views[key].classList.add('hidden');
                }
                // Deactivate all nav icons
                for (const key in dom.nav) {
                    dom.nav[key].classList.remove('active');
                }

                // Show selected view
                if (dom.views[viewName]) {
                    dom.views[viewName].classList.remove('hidden');
                    state.ui.activeView = viewName;
                }
                // Activate selected nav icon
                if (dom.nav[viewName]) {
                    dom.nav[viewName].classList.add('active');
                }
                
                // NEW: Initialize 3D scenes on demand
                if (viewName === 'glazery' && !isThreeJSInitialized) {
                    setTimeout(initThreeJS, 0); // Use setTimeout to avoid blocking
                }
                if (viewName === 'bakery' && !isBakeryThreeJSInitialized) {
                    setTimeout(initBakeryThreeJS, 0); // Use setTimeout
                }

                // Update UI for the new view
                updateUI();
                
                // Specific render calls
                if (viewName === 'bakery') { // Renamed: store -> bakery
                    renderBakery(); // Renamed: renderStore -> renderBakery
                    renderBakeryItemInfo();
                    updatePurchaseControls();
                    // NEW: Apply initial collapse state
                    applyBakeryCollapseState();
                }
                
                // NEW: Resize canvases when view changes
                setTimeout(onResize, 50);
            };

            // ===============================================================
            // GAME ACTIONS (NEW SECTION)
            // ===============================================================

            // NEW FUNCTION: handleMinerAction
            const handleMinerAction = () => {
                if (state.player.isBakerKing) {
                    // Claim "Bake"
                    const claimable = Math.floor(state.player.claimableBakeryCookies);
                    if (claimable > 0) {
                        playSoundEffect('purchase'); // NEW
                        state.player.cookies += claimable;
                        state.player.totalBakedCookies += claimable;
                        state.player.claimableBakeryCookies = 0;
                        console.log(`Claimed ${claimable} cookies.`);
                    }
                } else {
                    // Become "Glazer" (King)
                    playSoundEffect('purchase'); // NEW
                    // This is a mock action. In a real app, this would cost something.
                    state.player.isBakerKing = true;
                    state.player.glazeStartTime = Date.now(); // NEW: Start the timer
                    console.log("You are now the King Glazer!");
                }
                
                // Update UI immediately
                updateUI();
                
                // Rerender the bakery list to update costs/affordability
                if (state.ui.activeView === 'bakery') {
                    renderBakery();
                    updatePurchaseControls();
                }
            };

            const buyItem = () => { // Renamed: buyBuilding -> buyItem
                const name = state.ui.selectedItem;
                if (!name) return;

                const amount = parseInt(dom.bakeryPage.slider.value, 10);
                if (amount <= 0) return;

                const totalCost = getBulkItemCost(name, amount);

                if (state.player.cookies >= totalCost) {
                    playSoundEffect('purchase'); // NEW
                    state.player.cookies -= totalCost;
                    state.player.items[name] += amount; // Renamed: buildings -> items
                    state.player.productionPower = calculatePlayerProductionPower();
                    
                    console.log(`Bought ${amount} ${name}(s) for ${totalCost}`);

                    // Re-render everything
                    renderBakery(); // Update list
                    renderBakeryItemInfo(); // Update info box
                    
                    // NEW: Update purchase controls after buying
                    // This will recalculate max affordable and reset the slider/button text
                    updatePurchaseControls();
                    
                    // NEW: Update bar chart
                    if (state.ui.isItemListCollapsed) {
                        renderPowerBarChart();
                    }
                }
            };
            
            // NEW: Function to cycle through items
            const cycleItem = (direction) => {
                const itemKeys = Object.keys(state.items);
                let currentIndex = itemKeys.indexOf(state.ui.selectedItem);
                
                if (currentIndex === -1) {
                    // If nothing is selected, select the first or last item
                    selectItem(direction === 1 ? itemKeys[0] : itemKeys[itemKeys.length - 1]);
                    return;
                }
                
                let nextIndex = (currentIndex + direction + itemKeys.length) % itemKeys.length;
                selectItem(itemKeys[nextIndex]);
            };

            const selectItem = (name) => { // Renamed: selectBuilding -> selectItem
                if (state.ui.selectedItem === name) {
                    // Toggle off if clicking the same item
                    name = null;
                }
                
                state.ui.selectedItem = name; // Renamed: selectedBuilding -> selectedItem
                
                console.log("Selected item:", state.ui.selectedItem);

                // --- 3D MODEL LOGIC ---
                if (isBakeryThreeJSInitialized) { // Check if initialized
                    let targetZoom = 5; // NEW: Default zoom

                    if (name) {
                        // An item is selected
                        
                        // NEW: Show item controls
                        dom.bakeryPage.itemInfoContainer.classList.remove('hidden');
                        
                        // Show item model, hide bakery model
                        bakeryItemGroup.visible = true;
                        bakeryBuildingModelGroup.visible = false;
                        
                        // Clear previous model
                        while(bakeryItemGroup.children.length > 0){ 
                            bakeryItemGroup.remove(bakeryItemGroup.children[0]); 
                        }
                        
                        // Add new model
                        let model;
                        switch(name) {
                            case 'egg':
                                model = createEggModel();
                                targetZoom = 5; // User said is fine
                                break;
                            case 'milk':
                                model = createMilkModel();
                                targetZoom = 3.5; // Zoom in
                                break;
                            case 'cherries':
                                model = createCherriesModel();
                                targetZoom = 4; // Zoom in
                                break;
                            case 'bacon':
                                model = createBaconModel();
                                targetZoom = 4; // Zoom in
                                break;
                            case 'cookie':
                                model = createCookieModel();
                                targetZoom = 5;
                                break;
                            case 'blicky':
                                model = createBlickyModel();
                                targetZoom = 3.5; // Zoom in
                                break;
                            case 'grandma':
                                model = createGrandmaModel();
                                targetZoom = 5;
                                break;
                            case 'grapes': // NEW
                                model = createGrapesModel();
                                targetZoom = 4; // Zoom in
                                break;
                            case 'mine': // REMOVED 'farm'
                            case 'factory':
                                // For now, use the full bakery model as a placeholder
                                bakeryItemGroup.visible = false;
                                bakeryBuildingModelGroup.visible = true;
                                model = null; // No item model to add
                                targetZoom = 5; // Zoom for the factory/mine (which is the donut model)
                                break;
                            default:
                                model = createPlaceholderModel();
                                targetZoom = 5;
                        }
                        
                        if (model) {
                            bakeryItemGroup.add(model);
                        }
                        
                        // Show ticker
                        dom.bakeryPage.itemTickerWrap.classList.remove('hidden');
                        dom.bakeryPage.itemTickerText.textContent = `${state.items[name].emoji} ${state.items[name].description} ... ${state.items[name].emoji} ${state.items[name].description} ... `;

                    } else {
                        // Nothing selected
                        
                        // NEW: Hide item controls
                        dom.bakeryPage.itemInfoContainer.classList.add('hidden');

                        // Show bakery model, hide item model
                        bakeryItemGroup.visible = false;
                        bakeryBuildingModelGroup.visible = true;
                        targetZoom = 5; // NEW: Default zoom for powdered donut
                        
                        // Hide ticker
                        dom.bakeryPage.itemTickerWrap.classList.add('hidden');
                    }
                    
                    // NEW: Apply the target zoom
                    bakeryCamera.position.z = targetZoom;
                    bakeryCamera.updateProjectionMatrix();
                    bakeryCurrentCameraZ = targetZoom;
                    dom.bakeryPage.zoomSlider.value = targetZoom; // Sync slider
                }
                // --- END 3D MODEL LOGIC ---

                renderBakery(); // Re-render list to show selection
                renderBakeryItemInfo(); // Re-render info box
                
                // NEW: Update purchase controls on selection change
                dom.bakeryPage.slider.value = 1; // Reset slider to 1
                updatePurchaseControls();
            };
            

            // ===============================================================
            // GAME LOOP
            // ===============================================================
            
            const GAME_TICK_MS = 100;

            const gameLoop = () => {
                // Game logic (emission, halving, distribution) would go here
                
                // MOCK: Increment total mined cookies for countdown demo
                state.global.totalCookiesCreated += state.global.emissionRate * (GAME_TICK_MS / 1000);
                
                // ... (logic is placeholder as per context) ...
                updateUI();
            };

            // ===============================================================
            // INITIALIZATION
            // ===============================================================
            
            dom.nav.bakery.onclick = () => { playSoundEffect('crunch'); showView('bakery'); }; // Renamed, ADDED SFX
            dom.nav.glazery.onclick = () => { playSoundEffect('crunch'); showView('glazery'); }; // Renamed, ADDED SFX
            dom.nav.about.onclick = () => { playSoundEffect('crunch'); showView('about'); }; // ADDED SFX

            dom.glazery.actionButton.onclick = handleMinerAction; // Renamed: dom.miner -> dom.glazery, handleBakeryAction -> handleMinerAction
            dom.bakeryPage.purchaseButton.onclick = buyItem; // Renamed: dom.store -> dom.bakeryPage, buyBuilding -> buyItem
            dom.musicToggleButton.onclick = toggleMusic; // Assign music toggle function
            dom.sfxToggleButton.onclick = toggleSfx; // NEW
            dom.darkModeToggleButton.onclick = () => {
                playSoundEffect('crunch'); // NEW
                toggleDarkMode(); // NEW
            };
            dom.glazery.glazeColorButton.onclick = () => {
                playSoundEffect('crunch'); // NEW
                changeGlazeColor(); // Renamed: dom.miner -> dom.glazery
            };
            dom.bakeryPage.prevButton.onclick = () => {
                playSoundEffect('crunch'); // NEW
                cycleItem(-1); // NEW
            };
            dom.bakeryPage.nextButton.onclick = () => {
                playSoundEffect('crunch'); // NEW
                cycleItem(1); // NEW
            };

            // NEW: Event listeners for zoom sliders
            dom.glazery.zoomSlider.oninput = () => {
                if (!isThreeJSInitialized) return;
                const newZ = parseFloat(dom.glazery.zoomSlider.value);
                camera.position.z = newZ;
                camera.updateProjectionMatrix();
                currentCameraZ = newZ;
            };
            dom.bakeryPage.zoomSlider.oninput = () => {
                if (!isBakeryThreeJSInitialized) return;
                const newZ = parseFloat(dom.bakeryPage.zoomSlider.value);
                bakeryCamera.position.z = newZ;
                bakeryCamera.updateProjectionMatrix();
                bakeryCurrentCameraZ = newZ;
            };

            // NEW: Event listeners for purchase controls
            dom.bakeryPage.slider.oninput = updatePurchaseControls;
            dom.bakeryPage.maxButton.onclick = () => {
                playSoundEffect('crunch'); // NEW
                const name = state.ui.selectedItem;
                if (!name) return;
                const max = calculateMaxAffordable(name);
                dom.bakeryPage.slider.value = max;
                updatePurchaseControls();
            };
            
            // NEW: Event listener for item list collapse
            dom.bakeryPage.itemListToggle.onclick = () => {
                playSoundEffect('crunch'); // NEW
                state.ui.isItemListCollapsed = !state.ui.isItemListCollapsed;
                applyBakeryCollapseState(); // Use the new function
            };

            showView('bakery'); // Renamed: store -> bakery
            state.player.productionPower = calculatePlayerProductionPower(); // FIX: Removed typo 'calculatePlayerPlayerProductionPower'

            setInterval(gameLoop, GAME_TICK_MS); // FIX: Was just gameLoop
            
            // Init Glazery scene on load so animate() loop starts
            if (!isThreeJSInitialized) {
                setTimeout(initThreeJS, 0); 
            }
            
            // Start the single animation loop *after* both inits are queued
            animate();

            // setInterval(createFallingCookie, 500); // Paused
        });
    </script>
</body>
</html>














