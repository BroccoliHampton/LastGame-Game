<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Donut Miner ツ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Include Tone.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        /* =============================================================== */
        /* KISSAKI/TAMAGOTCHI AESTHETIC STYLING                            */
        /* =============================================================== */

        /* Custom Font - Nunito is a good match for the cute, rounded look */
        @import url('https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700;800;900&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Comic+Neue:wght@400;700&display=swap'); /* Changed to Comic Neue */
        @import url('https://fonts.googleapis.com/css2?family=Luckiest+Guy&display=swap'); /* NEW: Added Luckiest Guy font */
        
        /* This is the "browser" background, outside the phone */
        body {
            font-family: 'Nunito', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            overscroll-behavior: none; /* Prevents "pull-to-refresh" */
            
            /* Apply app-shell styling directly to body */
            background-color: #FFC0CB; /* Soft Pink */
            background-image: url("data:image/svg+xml,%3Csvg width='100' height='100' viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'%3E%3Cg opacity='0.7'%3E%3Crect x='10' y='10' width='3' height='10' fill='%23FFD700' transform='rotate(25 11.5 15)' /%3E%3Crect x='60' y='30' width='3' height='10' fill='%23FF69B4' transform='rotate(140 61.5 35)' /%3E%3Crect x='30' y='70' width='3' height='10' fill='%2390EE90' transform='rotate(70 31.5 75)' /%3E%3Crect x='80' y='85' width='3' height='10' fill='%2387CEEB' transform='rotate(210 81.5 90)' /%3E%3Crect x='5' y='45' width='3' height='10' fill='%23FFD700' transform='rotate(100 6.5 50)' /%3E%3Crect x='90' y='5' width='3' height='10' fill='%23FF69B4' transform='rotate(300 91.5 10)' /%3E%3C/g%3E%3C/svg%3E"), 
                            linear-gradient(135deg, #FFC0CB 0%, #FFDDE1 100%); /* Soft Pink base */
            background-size: 200px 200px, cover; /* Adjust size for sprinkles, cover for gradient */
            background-blend-mode: overlay, normal;
            background-attachment: fixed;
            color: #333333; /* Dark gray for general text */
            
            /* Ensure the body takes full viewport height and manages overflow */
            min-height: 100vh;
            display: flex; /* Use flexbox to organize main content and nav */
            flex-direction: column; /* Stack content vertically */
            padding: 0; /* Remove padding */
            margin: 0; /* Remove margin */
        }

        /* Custom Colors inspired by Tamagotchi */
        /* Changed to pale butter yellow */
        .bg-tamagotchi-bg-light { background-color: #FFFACD; } 
        .text-tamagotchi-dark { color: #333333; } /* General dark text */
        .text-tamagotchi-pink-dark { color: #E75480; } /* Stronger, cuter pink for accents/headings */
        .text-tamagotchi-pink-light { color: #FF9AA2; } /* Lighter pink for accents */
        
        /* Button colors */
        .bg-tamagotchi-button-pink { 
            background: linear-gradient(to bottom, #FFDDE1, #E75480); /* Puffy pink gradient */
            color: white;
            font-weight: 800;
            border: 2px solid #C04A70; /* Darker border for depth */
        }
        .bg-tamagotchi-button-teal { 
            background: linear-gradient(to bottom, #B3F0E6, #66CCBF); /* Teal gradient */
            color: white;
            font-weight: 800;
            border: 2px solid #50A89C; /* Darker border for depth */
        }
        .bg-tamagotchi-button-pink:active, .bg-tamagotchi-button-teal:active {
            transform: translateY(1px); /* Simple press effect */
            box-shadow: none;
        }

        /* Border/Card colors */
        .border-tamagotchi-subtle { border-color: #E0E0E0; } /* Light gray border */
        /* Changed to pale butter yellow */
        .bg-tamagotchi-card { 
            background-color: #FFFACD; /* Pale Butter Yellow for cards */
            border: 2px solid #E0E0E0; /* Subtle border */
        }
        .border-tamagotchi-accent-pink { border-color: #FF9AA2; /* Pink accent border */
        }

        /* General rounding */
        .rounded-tamagotchi-lg { border-radius: 20px; } /* More pronounced rounding for cards/buttons */
        .rounded-tamagotchi-md { border-radius: 14px; } /* Medium rounding */
        .rounded-tamagotchi-full { border-radius: 9999px; } /* Full rounding for circular elements */

        /* Shadows (softer, toy-like) */
        .shadow-tamagotchi { box-shadow: 0px 6px 15px rgba(0, 0, 0, 0.1); } /* More pronounced, softer shadow */
        
        .nav-icon span {
            font-size: 32px; /* Large emoji */
            color: #A0A0A0; /* Soft gray for inactive icons */
            transition: color 0.2s ease-in-out, transform 0.2s ease-in-out;
        }
        .nav-icon.active span {
            color: #E75480; /* Stronger pink for active icon */
            transform: scale(1.1);
        }

        /* Style for the 3D canvas */
        #cookie-canvas {
            width: 100%;
            height: 100%;
            max-width: 400px; /* Keep max width to prevent distortion on very wide screens */
            max-height: 400px; /* Keep max height */
            cursor: grab;
            touch-action: none;
            position: relative; /* Ensure canvas is positioned above static */
            z-index: 20; /* Higher than static */
            margin: auto; /* Center the canvas */
        }
        #cookie-canvas:active {
            cursor: grabbing;
        }

        /* Glaze color button styling */
        .color-cycle-button { /* Applied to both glaze and sprinkle buttons */
            position: absolute; /* Will be positioned relative to parent */
            bottom: 10px;
            width: 32px; /* Smaller width */
            height: 32px; /* Smaller height */
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px; /* Smaller font size */
            border-radius: 50%; /* Circular button */
            cursor: pointer;
            border: 2px solid #E0E0E0; /* Subtle border */
            background-color: #f0f0f0; /* Default light background */
            box-shadow: 0px 2px 5px rgba(0,0,0,0.2);
            transition: transform 0.1s ease-in-out, background-color 0.2s;
            z-index: 30; /* Ensure it's above other elements in the container */
        }
        .color-cycle-button:active {
            transform: translateY(1px);
            box-shadow: none;
        }
        /* Specific positioning */
        #glaze-color-button {
            right: 8px; /* Adjusted right spacing */
        }
        #sprinkle-color-button { /* New button */
            right: 48px; /* 8px (glaze) + 32px (button width) + 8px (gap) */
        }
        #donut-base-color-button { /* NEW */
            right: 88px; /* 48px (sprinkle) + 32px (button width) + 8px (gap) */
        }


        /* =============================================================== */
        /* GLITCHY STATIC TV EFFECT (Pale Butter Yellow Background)      */
        /* =============================================================== */

        .glitch-static {
            position: relative; /* Needed for pseudo-elements */
            overflow: hidden;
            background-color: #FFFACD !important; /* Pale Butter Yellow background - Added !important to override */
        }

        .glitch-static::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                linear-gradient(rgba(240, 230, 200, 0.4) 1px, transparent 1px), /* Softer static lines, matching yellow */
                linear-gradient(90deg, rgba(240, 230, 200, 0.4) 1px, transparent 1px);
            background-size: 4px 4px; /* Slightly larger static pixels */
            animation: static-flicker 0.5s infinite alternate, static-move 3s steps(10) infinite; /* Slower animations */
            opacity: 0.6; /* Softer static */
            pointer-events: none; /* Allows clicks/interactions with elements behind it */
            z-index: 15; /* Below donut, above container bg */
        }

        .glitch-static::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                to bottom,
                transparent 0%,
                rgba(240, 230, 200, 0.2) 50%, /* Softer yellow scanline */
                transparent 100%
            );
            mix-blend-mode: overlay; /* Creates light distortion effect */
            animation: scanline 8s linear infinite; /* Slower scanline */
            opacity: 0.3; /* Slightly more pronounced scanline */
            pointer-events: none;
            z-index: 16; /* Slightly above main static */
        }

        @keyframes static-flicker {
            0% { background-position: 0 0; opacity: 0.6; }
            50% { background-position: 8px 8px; opacity: 0.5; } /* Larger displacement for flicker */
            100% { background-position: 0 0; opacity: 0.7; }
        }

        @keyframes static-move {
            0% { transform: translate(0, 0); }
            100% { transform: translate(0, 100%); }
        }

        @keyframes scanline {
            0% { background-position: 0 0; }
            100% { background-position: 0 100%; }
        }

        /* =============================================================== */
        /* FALLING SNOW (GREY PIXELS) EFFECT                              */
        /* =============================================================== */
        .falling-snow {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 17; /* Above static, below donut */
            overflow: hidden; /* Ensures snowflakes don't go outside */
        }

        .falling-snow::before,
        .falling-snow::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                /* Create many small grey "pixels" */
                radial-gradient(circle at 10% 20%, #A0A0A0 1px, transparent 1px),
                radial-gradient(circle at 70% 80%, #C0C0C0 1px, transparent 1px),
                radial-gradient(circle at 30% 60%, #B0B0B0 1px, transparent 1px),
                radial-gradient(circle at 90% 10%, #E0E0E0 1px, transparent 1px),
                radial-gradient(circle at 50% 40%, #D0D0D0 1px, transparent 1px),
                radial-gradient(circle at 20% 90%, #F0F0F0 1px, transparent 1px),
                radial-gradient(circle at 80% 30%, #A0A0A0 1px, transparent 1px),
                radial-gradient(circle at 40% 70%, #C0C0C0 1px, transparent 1px),
                radial-gradient(circle at 60% 5%, #B0B0B0 1px, transparent 1px),
                radial-gradient(circle at 5% 50%, #E0E0E0 1px, transparent 1px),
                radial-gradient(circle at 95% 45%, #D0D0D0 1px, transparent 1px);
            background-repeat: repeat;
            background-size: 20px 20px; /* Control the density */
            animation: snowfall 10s linear infinite; /* Slower fall */
            opacity: 0.7; /* Make them subtle */
        }

        .falling-snow::after {
            animation-delay: 5s; /* Stagger the animation for more continuous effect */
            background-size: 25px 25px; /* Different size for variety */
            opacity: 0.6;
            filter: blur(0.5px); /* Slight blur for depth */
        }

        @keyframes snowfall {
            0% { transform: translateY(-100%); }
            100% { transform: translateY(100%); }
        }

        /* =============================================================== */
        /* SCROLLING TICKER                                                */
        /* =============================================================== */
        .ticker-wrap {
            width: 100%;
            overflow: hidden;
            background-color: #333; /* Dark background */
            padding: 4px 0; /* Vertical padding */
            border-top: 2px solid #555;
            border-bottom: 2px solid #555;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
        }
        
        /* Specific margins for top and bottom tickers */
        #top-ticker { margin-bottom: 8px; }
        #bottom-ticker { margin-top: 8px; }


        .ticker-move {
            display: inline-block;
            white-space: nowrap;
            animation: scroll-ticker 20s linear infinite; /* Adjust duration for speed */
            color: #FFFACD; /* Pale Butter Yellow text */
            font-size: 14px;
            font-weight: bold;
            font-family: 'Comic Neue', cursive; /* Match other text */
            text-shadow: 1px 1px 1px rgba(0,0,0,0.5);
        }

        .ticker-move-reverse {
            display: inline-block;
            white-space: nowrap;
            animation: scroll-ticker-reverse 20s linear infinite; /* Adjust duration for speed */
            color: #FFFACD; /* Pale Butter Yellow text */
            font-size: 14px;
            font-weight: bold;
            font-family: 'Comic Neue', cursive; /* Match other text */
            text-shadow: 1px 1px 1px rgba(0,0,0,0.5);
        }

        @keyframes scroll-ticker {
            0% { transform: translateX(0%); } /* Start visible */
            100% { transform: translateX(-50%); } /* Move halfway, showing the duplicated text */
        }

        @keyframes scroll-ticker-reverse {
            0% { transform: translateX(-50%); } /* Start halfway */
            100% { transform: translateX(0%); } /* Move back to start */
        }
        
        /* =============================================================== */
        /* DARK MODE STYLING                                               */
        /* =============================================================== */

        /* Chocolate brown background */
        body.dark { /* Changed from #app-shell.dark to body.dark */
            background-color: #5C3317; /* Chocolate Brown */
            background-image: url("data:image/svg+xml,%3Csvg width='20' height='20' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='%236B4A34' fill-opacity='0.4'%3E%3Cpath d='M10 0L0 10l10 10 10-10z'/%3E%3Cpath d='M0 10L10 20l10-10L10 0z'/%3E%3C/g%3E%3C/svg%3E"), 
                            linear-gradient(135deg, #5C3317 0%, #3D2B1F 100%);
        }

        /* Dark cards */
        body.dark .bg-tamagotchi-card { /* Changed from #app-shell.dark to body.dark */
            background-color: #3D2B1F; /* Dark, rich brown */
            border-color: #4A3A2A; /* Darker border */
        }
        
        /* Light text for dark backgrounds */
        body.dark .text-tamagotchi-dark { color: #F5E6C1; } /* Creamy white text */
        body.dark .text-gray-500 { color: #A8998A; } /* Lighter, desaturated brown text */
        body.dark .text-gray-600 { color: #B8A99A; }
        
        /* Pinks can stay, they pop nicely on brown */
        body.dark .text-tamagotchi-pink-dark { color: #FF9AA2; } /* Lighten the pink a bit */

        /* Glitch background */
        body.dark .glitch-static { /* Changed from #app-shell.dark to body.dark */
            background-color: #3D2B1F !important; /* Dark brown */
        }
        body.dark .glitch-static::before { /* Changed from #app-shell.dark to body.dark */
            background: 
                linear-gradient(rgba(150, 130, 110, 0.4) 1px, transparent 1px),
                linear-gradient(90deg, rgba(150, 130, 110, 0.4) 1px, transparent 1px);
        }
        body.dark .glitch-static::after { /* Changed from #app-shell.dark to body.dark */
            background: linear-gradient(
                to bottom,
                transparent 0%,
                rgba(150, 130, 110, 0.2) 50%,
                transparent 100%
            );
        }
        
        /* Falling snow (grey pixels) will look good on dark */
        body.dark .falling-snow::before { /* Changed from #app-shell.dark to body.dark */
            opacity: 0.4;
        }
        body.dark .falling-snow::after { /* Changed from #app-shell.dark to body.dark */
            opacity: 0.3;
        }

        /* Subtle borders */
        body.dark .border-tamagotchi-subtle { border-color: #4A3A2A; } /* Changed from #app-shell.dark to body.dark */
        
        /* Light-on-dark for nav */
        body.dark .nav-icon span { /* Changed from #app-shell.dark to body.dark */
            color: #A8998A; /* Lighter inactive icon */
        }
        body.dark .nav-icon.active span { /* Changed from #app-shell.dark to body.dark */
            color: #FF9AA2; /* Lighter active pink */
        }
        
        /* Color cycle button */
        body.dark .color-cycle-button { /* Changed from #app-shell.dark to body.dark */
            background-color: #3D2B1F;
            border-color: #4A3A2A;
            color: #F5E6C1; /* Light text */
        }
        
        /* App background for sticky footer */
        body.dark .bg-tamagotchi-bg-light { /* Changed from #app-shell.dark to body.dark */
            background-color: #3D2B1F; /* Dark brown */
        }

        /* NEW: Zoom Slider Styling */
        .zoom-slider {
            position: absolute;
            top: 50%;
            right: 8px; /* Adjusted to match new button spacing */
            transform: translateY(-50%); /* Center vertically */
            width: 16px; /* Track thickness */
            height: 100px; /* Track length */
            -webkit-appearance: none;
            appearance: none;
            writing-mode: vertical-lr; /* Make it vertical */
            direction: ltr;
            background: rgba(0, 0, 0, 0.1);
            border-radius: 8px; /* Slightly smaller border radius */
            z-index: 30;
            padding: 0;
            transition: background 0.2s;
        }
        /* Dark mode style for slider */
        body.dark .zoom-slider { /* Changed from #app-shell.dark to body.dark */
            background: rgba(255, 255, 255, 0.2);
        }

        /* Thumb styling */
        .zoom-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 22px; /* Touch target */
            height: 22px;
            background: #FFFACD; /* Pale Butter Yellow */
            border-radius: 50%;
            border: 2px solid #E75480; /* Pink border */
            cursor: grab;
        }
        .zoom-slider::-moz-range-thumb {
            width: 22px;
            height: 22px;
            background: #FFFACD;
            border-radius: 50%;
            border: 2px solid #E75480;
            cursor: grab;
        }
        /* Dark mode thumb */
        body.dark .zoom-slider::-webkit-slider-thumb { /* Changed from #app-shell.dark to body.dark */
            background: #3D2B1F; /* Dark brown */
            border-color: #FF9AA2; /* Lighter pink */
        }
        body.dark .zoom-slider::-moz-range-thumb { /* Changed from #app-shell.dark to body.dark */
            background: #3D2B1F;
            border-color: #FF9AA2;
        }
        /* END NEW STYLES */

    </style>
</head>
<body class="text-tamagotchi-dark">
        
    <main class="flex-grow flex flex-col px-3 pt-4 pb-1 overflow-y-auto max-w-lg mx-auto w-full"> <!-- Added max-w-lg mx-auto w-full for content centering --><div class="flex justify-between items-center mb-2">
            <div class="flex flex-col">
                <h1 class="text-3xl font-black text-tamagotchi-pink-dark" style="font-family: 'Luckiest Guy', cursive;">Donut Miner</h1>
                
                <!-- NEW: Profile Name Section (MOVED & SHRUNK) --><div class="bg-tamagotchi-card rounded-tamagotchi-lg shadow-tamagotchi p-2 flex items-center space-x-3 mt-1">
                    <div>
                        <div id="player-profile-name" class="font-extrabold text-sm truncate text-tamagotchi-dark">DonutEnthusiast_123</div>
                    </div>
                </div>
                <!-- END: Profile Name Section --></div>
            <div class="grid grid-cols-2 gap-1 self-start"> <!-- MODIFIED: Changed to grid --><!-- Row 1 --><button id="dark-mode-toggle-button" class="bg-tamagotchi-button-teal text-white text-base w-8 h-8 flex items-center justify-center rounded-tamagotchi-md shadow-tamagotchi active:opacity-80"> <!-- MODIFIED: Size/Text -->🌙
                </button>
                <button id="info-button" class="bg-tamagotchi-button-pink text-white text-base w-8 h-8 flex items-center justify-center rounded-tamagotchi-md shadow-tamagotchi active:opacity-80"> <!-- MODIFIED: Size/Text & MOVED -->❓
                </button>
                <!-- Row 2 --><button id="music-toggle-button" class="bg-tamagotchi-button-pink text-white text-base w-8 h-8 flex items-center justify-center rounded-tamagotchi-md shadow-tamagotchi active:opacity-80"> <!-- MODIFIED: Size/Text -->🔇
                </button>
                <button id="sfx-toggle-button" class="bg-tamagotchi-button-teal text-white text-base w-8 h-8 flex items-center justify-center rounded-tamagotchi-md shadow-tamagotchi active:opacity-80"> <!-- MODIFIED: Size/Text -->🔊
                </button>
            </div>
        </div>

        <!-- =============================================================== --><!-- GLAZERY VIEW (Restored)                                       --><!-- =============================================================== --><div id="view-glazery" class="flex-grow flex flex-col">
            <!-- REMOVED: Glazery h2 Subtitle --><!-- REMOVED: Profile Name Section --><div class="bg-tamagotchi-card rounded-tamagotchi-lg shadow-tamagotchi p-2 grid grid-cols-3 gap-2">
                <div class="text-center">
                    <div class="text-xs text-gray-500 font-semibold">King Glazer</div>
                    <div id="bakery-king-status" class="font-extrabold text-sm truncate text-tamagotchi-dark">None</div>
                </div>
                <div class="text-center">
                    <div class="text-xs text-gray-500 font-semibold">Glazed</div>
                    <div class="font-extrabold text-sm text-tamagotchi-dark">🍩 <span id="bakery-cps">0.00</span></div>
                </div>
                <div class="text-center">
                    <div class="text-xs text-gray-500 font-semibold">Glaze Time</div>
                    <div class="font-extrabold text-sm text-tamagotchi-dark"><span id="bakery-baked">00:00:00</span></div>
                </div>
            </div>

            <!-- MOVED: Second Row of Stats DIV was here --><div id="top-ticker" class="ticker-wrap" style="margin-bottom: 4px; margin-top: 8px;"> <!-- MODIFIED: Added margin-top --><div class="ticker-move">
                    <!-- UPDATED TEXT --><span>Glaze price doubles each time a new Glazer takes over, and price cools down to $0 over 1 hour. ... Glaze price doubles each time a new Glazer takes over, and price cools down to $0 over 1 hour. ... </span>
                </div>
            </div>

            <div id="cookie-rain-container" class="relative h-64 flex items-center justify-center overflow-hidden bg-tamagotchi-card rounded-tamagotchi-lg shadow-tamagotchi glitch-static">
                <div class="falling-snow"></div>
                <canvas id="cookie-canvas"></canvas>
                <button id="glaze-color-button" class="color-cycle-button shadow-tamagotchi bg-white text-tamagotchi-dark">🎨</button>
                <button id="sprinkle-color-button" class="color-cycle-button shadow-tamagotchi bg-white text-tamagotchi-dark">🌈</button> <!-- NEW: Sprinkle color button --><button id="donut-base-color-button" class="color-cycle-button shadow-tamagotchi bg-white text-tamagotchi-dark">🍩</button> <!-- NEW: Donut base color button --><!-- NEW: Zoom Slider --><input id="glazery-zoom-slider" type="range" class="zoom-slider">
            </div>

            <div id="bottom-ticker" class="ticker-wrap" style="margin-top: 4px;">
                <div class="ticker-move-reverse">
                    <!-- UPDATED TEXT --><span>Glaze price doubles each time a new Glazer takes over, and price cools down to $0 over 1 hour. ... Glaze price doubles each time a new Glazer takes over, and price cools down to $0 over 1 hour. ... </span>
                </div>
            </div>
            
            <div class="bg-tamagotchi-card text-tamagotchi-dark p-2 rounded-tamagotchi-lg shadow-tamagotchi">
                <div class="flex justify-between items-center">
                    <div>
                        <div class="text-xs font-semibold text-gray-600">Glaze Price</div>
                        <div id="glaze-price-display" class="text-xl font-extrabold text-tamagotchi-dark">Loading...</div>
                        <div id="glaze-price-subtext" class="text-xs text-gray-500">Fetching price...</div>
                    </div>
                    <button id="bakery-action-button" class="bg-tamagotchi-button-pink text-white py-2 px-6 rounded-tamagotchi-md text-sm font-bold active:opacity-80 disabled:opacity-50 shadow-tamagotchi">
                        Glaze
                    </button>
                </div>
            </div>

            <!-- NEW: Second Row of Stats --><div class="bg-tamagotchi-card rounded-tamagotchi-lg shadow-tamagotchi p-2 grid grid-cols-3 gap-2 mt-2">
                <div class="text-center">
                    <div class="text-xs text-gray-500 font-semibold">Donut Balance</div>
                    <div id="player-donut-balance" class="font-extrabold text-sm truncate text-tamagotchi-dark">0</div>
                </div>
                <div class="text-center">
                    <div class="text-xs text-gray-500 font-semibold">Total Glaze Time</div>
                    <div id="player-total-glaze-time" class="font-extrabold text-sm text-tamagotchi-dark">00:00:00</div>
                </div>
                <div class="text-center">
                    <div class="text-xs text-gray-500 font-semibold">% Mined</div>
                    <div class="font-extrabold text-sm text-tamagotchi-dark"><span id="player-percent-mined">0.00</span>%</div>
                </div>
            </div>

        </div>

        <!-- =============================================================== --><!-- ABOUT VIEW (Restored)                                         --><!-- =============================================================== --><!-- REMOVED view-about DIV --><!-- BAKERY VIEW REMOVED --></main>

    <!-- REMOVED nav ELEMENT --><!-- NEW INFO MODAL --><div id="info-modal-overlay" class="fixed inset-0 bg-black bg-opacity-50 z-40 hidden"></div>
    <div id="info-modal" class="fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-tamagotchi-card rounded-tamagotchi-lg shadow-tamagotchi p-4 z-50 hidden w-11/12 max-w-xs text-tamagotchi-dark overflow-y-auto" style="max-height: 90vh;">
        <div class="flex justify-between items-center mb-2">
            <h3 class="text-xl font-bold text-tamagotchi-pink-dark">Info</h3>
            <button id="info-modal-close" class="text-2xl font-bold text-gray-500 hover:text-tamagotchi-pink-dark">&times;</button>
        </div>
        <!-- CONTENT MOVED FROM 'ABOUT' TAB --><div class="space-y-3">
            <!-- UPDATED INFO TEXT --><div class="bg-tamagotchi-card rounded-tamagotchi-lg shadow-tamagotchi p-4 space-y-4 text-tamagotchi-dark">
                <p class="font-bold text-lg" style="font-family: 'Comic Neue', cursive;">
                    Hello and welcome to Donut Miner!
                </p>
                <p class="text-sm">
                    Pay the Glaze Price to become <strong>King Glazer</strong> and earn <strong>100%</strong> of the $DONUT emissions until you are replaced.
                </p>
                <p class="text-sm">
                    Glaze price doubles each time a new Glazer takes over, and price cools down to $0 over 1 hour.
                </p>
            </div>
            <!-- END UPDATED INFO TEXT --><!-- NEW: Global Donut Stats --><h3 class="text-xl font-bold text-tamagotchi-pink-dark pt-2">Global Donut Stats</h3>
            <div class="bg-tamagotchi-card rounded-tamagotchi-lg shadow-tamagotchi p-4 space-y-3 text-tamagotchi-dark">
                
                <div class="flex justify-between items-center">
                    <span class="text-sm font-semibold text-gray-600">Total Donut Supply</span>
                    <span id="modal-total-supply" class="font-extrabold text-tamagotchi-dark">🍩 0</span>
                </div>
                
                <div class="flex justify-between items-center">
                    <span class="text-sm font-semibold text-gray-600">Total % Mined</span>
                    <span id="modal-percent-mined" class="font-extrabold text-tamagotchi-dark">0.00%</span>
                </div>

                <div class="flex justify-between items-center">
                    <span class="text-sm font-semibold text-gray-600">Time Until Halving</span>
                    <span id="modal-next-halving" class="font-extrabold text-tamagotchi-dark">--:--:--</span>
                </div>

                <div class="flex justify-between items-center">
                    <span class="text-sm font-semibold text-gray-600">Total Miners</span>
                    <span id="modal-total-miners" class="font-extrabold text-tamagotchi-dark">👤 0</span>
                </div>

            </div>
            <!-- END NEW SECTION --></div>
        <!-- END MOVED CONTENT --></div>

<script>
        document.addEventListener('DOMContentLoaded', () => {

            // ===============================================================
            // GAME STATE
            // ===============================================================
            
            const state = {
                // Player State
                player: {
                    cookies: 1000000,
                    isBakerKing: false,
                    claimableBakeryCookies: 0,
                    totalBakedCookies: 0,
                    glazeStartTime: null,
                    totalGlazeTimeMs: 0, // NEW: Track total time
                },
                // Global Game State
                global: {
                    emissionRate: 10,
                    totalCookiesCreated: 0,
                    nextHalvingAt: 1000000,
                    totalDonutSupply: 1000000000,
                    totalMiners: 1234,
                },
                // UI State
                ui: {
                    // REMOVED activeView
                    isDarkMode: false,
                    isSfxMuted: false
                }
            };

            // ===============================================================
            // DOM ELEMENTS
            // ===============================================================
            const dom = {
                // REMOVED views property
                // REMOVED aboutPage property
                // REMOVED nav property
                glazery: {
                    kingStatus: document.getElementById('bakery-king-status'),
                    cps: document.getElementById('bakery-cps'),
                    baked: document.getElementById('bakery-baked'),
                    actionButton: document.getElementById('bakery-action-button'),
                    canvas: document.getElementById('cookie-canvas'),
                    rainContainer: document.getElementById('cookie-rain-container'),
                    glazeColorButton: document.getElementById('glaze-color-button'),
                    sprinkleColorButton: document.getElementById('sprinkle-color-button'), // NEW
                    donutBaseColorButton: document.getElementById('donut-base-color-button'), // NEW
                    zoomSlider: document.getElementById('glazery-zoom-slider'),
                    // NEW: Second row stats
                    donutBalance: document.getElementById('player-donut-balance'),
                    totalGlazeTime: document.getElementById('player-total-glaze-time'),
                    percentMined: document.getElementById('player-percent-mined'),
                },
                priceDisplay: document.getElementById('glaze-price-display'),
                priceSubtext: document.getElementById('glaze-price-subtext'),
                musicToggleButton: document.getElementById('music-toggle-button'),
                sfxToggleButton: document.getElementById('sfx-toggle-button'),
                darkModeToggleButton: document.getElementById('dark-mode-toggle-button'),
                // NEW
                infoButton: document.getElementById('info-button'),
                infoModal: document.getElementById('info-modal'),
                infoModalOverlay: document.getElementById('info-modal-overlay'),
                infoModalClose: document.getElementById('info-modal-close'),
                // NEW: Modal info elements
                modalInfo: {
                    totalSupply: document.getElementById('modal-total-supply'),
                    percentMined: document.getElementById('modal-percent-mined'),
                    nextHalving: document.getElementById('modal-next-halving'),
                    totalMiners: document.getElementById('modal-total-miners'),
                }
            };

            // ===============================================================
            // HELPER FUNCTIONS
            // ===============================================================

            const format = (num) => Math.floor(num).toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, '$1,');
            const formatDecimal = (num) => num.toFixed(2);
            
            const formatGlazeTime = (ms) => {
                if (ms === null || ms < 0) {
                    return '00:00:00';
                }
                const totalSeconds = Math.floor(ms / 1000);
                const hours = Math.floor(totalSeconds / 3600);
                const minutes = Math.floor((totalSeconds % 3600) / 60);
                const seconds = totalSeconds % 60;
                
                return [hours, minutes, seconds]
                    .map(v => v.toString().padStart(2, '0'))
                    .join(':');
            };

            // ===============================================================
            // FETCH GLAZE PRICE FROM CONTRACT
            // ===============================================================
            
            const API_BASE_URL = 'https://last-game-kappa.vercel.app';
            
            async function fetchGlazePrice() {
                try {
                    console.log('[Price] Fetching glaze price...');
                    const response = await fetch(`${API_BASE_URL}/api/get-price`);
                    const data = await response.json();
                    
                    if (!response.ok) {
                        throw new Error(data.error || 'Failed to fetch price');
                    }
                    
                    const priceInUsdc = data.priceInUsdc;
                    console.log('[Price] Current price:', priceInUsdc, 'USDC');
                    
                    // Update the display
                    dom.priceDisplay.textContent = `$${priceInUsdc}`;
                    
                    // Update subtext based on price
                    if (parseFloat(priceInUsdc) === 0) {
                        dom.priceSubtext.textContent = 'Free to claim!';
                    } else {
                        dom.priceSubtext.textContent = `Pay to become King Glazer`;
                    }
                    
                    return data;
                } catch (error) {
                    console.error('[Price] Error fetching price:', error);
                    dom.priceDisplay.textContent = 'Error';
                    dom.priceSubtext.textContent = 'Failed to load price';
                    return null;
                }
            }

            // ===============================================================
            // AUDIO SETUP (Tone.js)
            // ===============================================================
            let kick, hiHat, bass, melody;
            let kickSequence, hiHatSequence, bassSequence, melodySequence;
            let isMusicPlaying = false;
            let isAudioInitialized = false;

            let purchaseSound, cuteClickSound;

            function initAudio() {
                if (isAudioInitialized) return;

                Tone.Transport.bpm.value = 140;
                Tone.Transport.swing = 0.2;
                Tone.Transport.swingSubdivision = '8n';
                const limiter = new Tone.Limiter(-6).toDestination();

                // 1. KICK DRUM
                kick = new Tone.MembraneSynth({
                    pitchDecay: 0.01,
                    octaves: 6,
                    oscillator: { type: 'sine' },
                    envelope: { attack: 0.001, decay: 0.3, sustain: 0.01, release: 0.2 }
                }).connect(limiter);
                
                const kickPattern = ['C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null, 'C2', null, null, null];
                
                kickSequence = new Tone.Sequence((time, note) => {
                    if (note) kick.triggerAttackRelease(note, '8n', time);
                }, kickPattern, '8n');
                kickSequence.loop = true;

                // 2. HI-HAT
                hiHat = new Tone.NoiseSynth({
                    noise: { type: 'white' },
                    envelope: { attack: 0.001, decay: 0.05, sustain: 0, release: 0.05 }
                }).connect(limiter);

                const hiHatPattern = [null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'G5', null, null, null, 'GC5', null];

                hiHatSequence = new Tone.Sequence((time, note) => {
                    if (note) hiHat.triggerAttackRelease('8n', time);
                }, hiHatPattern, '8n');
                hiHatSequence.loop = true;

                // 3. BASS LINE
                bass = new Tone.MonoSynth({
                    oscillator: { type: 'sawtooth' },
                    filter: { Q: 2, type: 'lowpass', cutoff: 400 },
                    envelope: { attack: 0.01, decay: 0.2, sustain: 0.3, release: 0.5 }
                }).connect(limiter);

                const bassPattern = ['C2', null, 'G2', null, 'C2', null, 'G2', null, 'C2', null, 'G2', null, 'C2', null, 'G2', null, 'C2', null, 'G2', null, 'C2', null, 'G2', null, 'C2', null, 'G2', null, 'C2', null, 'G2', null, 'G#1', null, 'D#2', null, 'G#1', null, 'D#2', null, 'G#1', null, 'D#2', null, 'G#1', null, 'D#2', null, 'G#1', null, 'D#2', null, 'G#1', null, 'D#2', null, 'G#1', null, 'D#2', null, 'G#1', null, 'D#2', null, 'F1', null, 'C2', null, 'F1', null, 'C2', null, 'F1', null, 'C2', null, 'F1', null, 'C2', null, 'F1', null, 'C2', null, 'F1', null, 'C2', null, 'F1', null, 'C2', null, 'F1', null, 'C2', null, 'G1', null, 'D2', null, 'G1', null, 'D2', null, 'G1', null, 'D2', null, 'G1', null, 'D2', null, 'G1', null, 'D2', null, 'G1', null, 'D2', null, 'G1', null, 'D2', null, 'G1', null, 'D2', 'D2'];

                bassSequence = new Tone.Sequence((time, note) => {
                    if (note) bass.triggerAttackRelease(note, '8n', time);
                }, bassPattern, '8n');
                bassSequence.loop = true;

                // 4. MELODY
                melody = new Tone.FMSynth({
                    harmonicity: 3,
                    modulationIndex: 10,
                    oscillator: { type: 'sine' },
                    envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.5 }
                }).connect(limiter);

                const melodyPattern = ['G4', 'A#4', 'C5', null, 'G4', 'D#4', null, null, 'G4', 'A#4', 'C5', null, 'D#5', 'C5', 'A#4', null, 'G4', 'A#4', 'C5', null, 'G4', 'D#4', null, null, 'G4', 'A#4', 'G4', 'D#4', 'C4', null, null, null, 'G#4', 'C5', 'D#5', null, 'C5', 'G#4', null, null, 'G#4', 'C5', 'D#5', null, 'F5', 'D#5', 'C5', null, 'G#4', 'C5', 'D#5', null, 'C5', 'G#4', null, null, 'C5', 'A#4', 'G#4', 'F4', 'D#4', null, null, null, 'F4', 'G#4', 'C5', null, 'G#4', 'F4', null, null, 'F4', 'G#4', 'C5', null, 'D#5', 'C5', 'G#4', null, 'F4', 'G#4', 'C5', null, 'G#4', 'F4', null, null, 'F4', 'G#4', 'F4', 'D#4', 'C4', null, null, null, 'G4', 'B4', 'D5', null, 'D5', 'B4', 'G4', null, 'G4', 'B4', 'D5', 'F5', 'D5', 'B4', 'G4', null, 'A#4', null, 'B4', null, 'C5', null, 'B4', 'A#4', 'G4', 'F4', 'D#4', 'D4', 'C4', null, null, null];
                
                melodySequence = new Tone.Sequence((time, note) => {
                    if (note) melody.triggerAttackRelease(note, '8n', time);
                }, melodyPattern, '8n');
                melodySequence.loop = true;

                // Initialize SFX
                cuteClickSound = new Tone.FMSynth({
                    oscillator: { type: 'sine' },
                    envelope: { attack: 0.001, decay: 0.05, sustain: 0, release: 0.1 },
                    harmonicity: 0.5,
                    modulationIndex: 2
                }).connect(limiter);
                
                purchaseSound = new Tone.Synth({
                    oscillator: { type: 'triangle' },
                    envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.2 }
                }).connect(limiter);

                isAudioInitialized = true;
            }

            function playSoundEffect(sound, ...args) {
                if (state.ui.isSfxMuted) return;

                if (Tone.context.state !== 'running') {
                    Tone.start();
                }
                
                if (!isAudioInitialized) {
                    initAudio();
                }
                
                if (!state.ui.isSfxMuted) {
                    if (sound === 'crunch') {
                        cuteClickSound.triggerAttackRelease('C6', '32n', Tone.now());
                    }
                    if (sound === 'purchase') {
                        purchaseSound.triggerAttackRelease('C5', '16n', Tone.now());
                        purchaseSound.triggerAttackRelease('E5', '16n', Tone.now() + 0.05);
                        purchaseSound.triggerAttackRelease('G5', '16n', Tone.now() + 0.1);
                    }
                }
            }
            
            function toggleSfx() {
                state.ui.isSfxMuted = !state.ui.isSfxMuted;
                dom.sfxToggleButton.textContent = state.ui.isSfxMuted ? '🔇' : '🔊';

                if (!state.ui.isSfxMuted) {
                    playSoundEffect('crunch');
                }
            }

            function toggleMusic() {
                if (Tone.context.state !== 'running') {
                    Tone.start();
                }

                if (!isAudioInitialized) {
                    initAudio();
                }

                if (isMusicPlaying) {
                    // NEW: Only stop the Transport. This stops all events
                    // and resets the Transport time to 0.
                    Tone.Transport.stop();
                    
                    /* REMOVED: Explicitly stopping sequences caused errors 
                       and issues restarting.
                    if (kickSequence) kickSequence.stop();
                    if (hiHatSequence) hiHatSequence.stop();
                    if (bassSequence) bassSequence.stop();
                    if (melodySequence) melodySequence.stop();
                    */
                    
                    dom.musicToggleButton.textContent = '🔇';
                } else {
                    Tone.Transport.start();
                    
                    // NEW: Check if sequences are 'stopped' before starting them.
                    // This ensures they start on the first play, and also
                    // restart correctly after being stopped by the Transport.
                    if (kickSequence && kickSequence.state === 'stopped') {
                         kickSequence.start(0);
                    }
                    if (hiHatSequence && hiHatSequence.state === 'stopped') {
                         hiHatSequence.start(0);
                    }
                    if (bassSequence && bassSequence.state === 'stopped') {
                         bassSequence.start(0);
                    }
                    if (melodySequence && melodySequence.state === 'stopped') {
                         melodySequence.start(0);
                    }

                    dom.musicToggleButton.textContent = '🎵';
                }
                isMusicPlaying = !isMusicPlaying;
            }

            // ===============================================================
            // DARK MODE TOGGLE (NEW)
            // ===============================================================
            function toggleDarkMode() {
                state.ui.isDarkMode = !state.ui.isDarkMode;
                const body = document.body; // Changed from appShell to body
                if (state.ui.isDarkMode) {
                    body.classList.add('dark');
                    dom.darkModeToggleButton.textContent = '☀️';
                } else {
                    body.classList.remove('dark');
                    dom.darkModeToggleButton.textContent = '🌙';
                }
            }

            // ===============================================================
            // INFO MODAL (NEW)
            // ===============================================================
            function showInfoModal() {
                playSoundEffect('crunch');
                dom.infoModal.classList.remove('hidden');
                dom.infoModalOverlay.classList.remove('hidden');
            }

            function hideInfoModal() {
                // No sound on close, feels better
                // playSoundEffect('crunch'); 
                dom.infoModal.classList.add('hidden');
                dom.infoModalOverlay.classList.add('hidden');
            }

            // ===============================================================
            // 3D GLAZERY SETUP
            // ===============================================================

            let scene, camera, renderer, donutGroup, glazeMaterial, donutMaterial, sprinkleMeshes = []; // MODIFIED: Added donutMaterial, sprinkleMeshes
            let isDragging = false;
            let previousPointerX = 0;
            let previousPointerY = 0;
            let initialPinchDistance = 0;
            let currentCameraZ = 10;
            let isThreeJSInitialized = false; 
            let donutSpinSpeed = 0.005; // NEW: Control variable for spin speed

            const MIN_ZOOM_Z = 3;
            const MAX_ZOOM_Z = 20;

            const glazeColors = [
                0xFFC0CB, // Original Pink
                0xADD8E6, // Light Blue
                0x90EE90, // Light Green
                0xFFD700, // Gold (Yellow)
                0x800080, // Purple
                0xFFF8DC, // Cream
                0xFF0000, // Red
                0x000000  // Black
            ];
            let currentGlazeColorIndex = 0;

            const donutBaseColors = [ // NEW
                0x5C3317, // Original Brown
                0xDEB887, // BurlyWood (Lighter)
                0x3D2B1F, // Dark Brown
                0xF5DEB3, // Wheat
                0xFFC0CB, // Pink (for fun)
                null      // NEW: Wireframe flag
            ];
            let currentDonutBaseColorIndex = 0;

            const sprinkleColorSets = [ // NEW: Sprinkle color sets
                [0xFF0000, 0xFF7F00, 0xFFFF00, 0x00FF00, 0x0000FF, 0x4B0082, 0x9400D3], // Rainbow
                [0xFFFFFF, 0xF0F0F0, 0xE0E0E0], // White/Silver
                [0x000000, 0x333333, 0x666666], // Black/Grey
                [0xFFC0CB, 0xFF9AA2, 0xFFDDE1], // Pink Tones
                [0x87CEEB, 0xADD8E6, 0xB0E0E6], // Blue Tones
                [0xDAA520, 0xB8860B, 0xFFD700]  // Gold Tones
            ];
            let currentSprinkleColorSetIndex = 0;

            function createCrackTexture(size = 1024) {
                const canvas = document.createElement('canvas');
                canvas.width = size;
                canvas.height = size;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, size, size);

                ctx.strokeStyle = '#333333';
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                for (let i = 0; i < 15; i++) {
                    ctx.beginPath();
                    let startX = Math.random() * size;
                    let startY = Math.random() * size;
                    ctx.moveTo(startX, startY);
                    let len = Math.random() * 60 + 30;
                    let currentX = startX;
                    let currentY = startY;
                    for (let j = 0; j < 5; j++) {
                         currentX += (Math.random() - 0.5) * len;
                         currentY += (Math.random() - 0.5) * len;
                         currentX = Math.max(0, Math.min(size, currentX));
                         currentY = Math.max(0, Math.min(size, currentY));
                        ctx.lineTo(currentX, currentY);
                        len *= 0.8;
                    }
                    ctx.stroke();
                }

                return new THREE.CanvasTexture(canvas);
            }

            function createSpeckleTexture(size = 512, color = 'rgba(0,0,0,0.5)') {
                const canvas = document.createElement('canvas');
                canvas.width = size;
                canvas.height = size;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#FFFFFF'; 
                ctx.fillRect(0, 0, size, size);

                for (let i = 0; i < 2000; i++) {
                    const x = Math.random() * size;
                    const y = Math.random() * size;
                    const r = Math.random() * 0.8 + 0.4;
                    const alpha = Math.random() * 0.5 + 0.3;
                    const shade = Math.floor(Math.random() * 40);
                    ctx.fillStyle = `rgba(${shade}, ${shade}, ${shade}, ${alpha})`; 
                    
                    ctx.beginPath();
                    ctx.arc(x, y, r, 0, Math.PI * 2);
                    ctx.fill();
                }

                return new THREE.CanvasTexture(canvas);
            }

            function initThreeJS() {
                if (isThreeJSInitialized) return; 
                
                scene = new THREE.Scene();
                
                const container = dom.glazery.rainContainer;
                if (!container) return;
                const w = container.clientWidth || 300;
                const h = container.clientHeight || 300;

                camera = new THREE.PerspectiveCamera(75, w / h, 0.1, 1000);
                camera.position.z = currentCameraZ;

                if (!dom.glazery.canvas) return;
                renderer = new THREE.WebGLRenderer({ 
                    canvas: dom.glazery.canvas,
                    alpha: true
                });
                renderer.setSize(w, h);
                renderer.setPixelRatio(window.devicePixelRatio);

                const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
                scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7); 
                directionalLight.position.set(5, 5, 5);
                scene.add(directionalLight);

                donutGroup = new THREE.Group();
                
                // Donut Base
                const donutGeometry = new THREE.TorusGeometry(2.8, 1.3, 32, 100);

                const crackTexture = createCrackTexture(1024);
                crackTexture.wrapS = crackTexture.wrapT = THREE.RepeatWrapping;
                crackTexture.repeat.set(1, 1);
                
                const speckleTexture = createSpeckleTexture(512);
                speckleTexture.wrapS = speckleTexture.wrapT = THREE.RepeatWrapping;
                speckleTexture.repeat.set(3, 3);

                donutMaterial = new THREE.MeshStandardMaterial({ // MODIFIED: Assigned to global var
                    color: donutBaseColors[currentDonutBaseColorIndex], // MODIFIED: Use color from array
                    roughness: 0.8,
                    metalness: 0.05,
                    map: speckleTexture,
                    bumpMap: crackTexture,
                    bumpScale: 0.08
                });
                const donutBase = new THREE.Mesh(donutGeometry, donutMaterial);
                donutGroup.add(donutBase);

                // Glaze Layer
                const glazeRadius = 2.75; 
                const glazeTubeRadius = 1.35; 
                const radialSegments = 32; 
                const tubularSegments = 100;

                const glazeGeometry = new THREE.TorusGeometry(
                    glazeRadius,
                    glazeTubeRadius,
                    radialSegments,
                    tubularSegments
                );
                
                const positionAttribute = glazeGeometry.attributes.position;
                const tempVector = new THREE.Vector3();
                const irregularityFactor = 0.15; 
                const randomOffsets = new Array(tubularSegments).fill(0).map(() => Math.random() * irregularityFactor * 2 - irregularityFactor);

                for (let i = 0; i < positionAttribute.count; i++) {
                    tempVector.fromBufferAttribute(positionAttribute, i);

                    const x = tempVector.x;
                    const y = tempVector.y;
                    const z = tempVector.z;
                    const r = Math.sqrt(x * x + y * y);
                    const angleAroundDonut = Math.atan2(y, x); 
                    const distFromGlazeMainRadius = Math.abs(r - glazeRadius);
                    const isOuterEdge = distFromGlazeMainRadius < (glazeTubeRadius * 0.4) && r > glazeRadius; 
                    const isBottomHalf = z < -0.4 * glazeTubeRadius; 
                    const isInnerEdge = distFromGlazeMainRadius < (glazeTubeRadius * 0.4) && r < glazeRadius;

                    if (isOuterEdge && isBottomHalf) {
                        const segmentIndex = Math.floor((angleAroundDonut / (2 * Math.PI)) * tubularSegments + tubularSegments) % tubularSegments;
                        const scallopMagnitude = 0.1 + (randomOffsets[segmentIndex] * 0.8 + 0.5) * 0.1; 
                        const currentRadius = Math.sqrt(tempVector.x * tempVector.x + tempVector.y * tempVector.y);
                        const normalizedX = tempVector.x / currentRadius;
                        const normalizedY = tempVector.y / currentRadius;

                        tempVector.x += normalizedX * scallopMagnitude;
                        tempVector.y += normalizedY * scallopMagnitude;
                        tempVector.z += scallopMagnitude * 0.5; 
                        positionAttribute.setXYZ(i, tempVector.x, tempVector.y, tempVector.z);
                    } else if (isInnerEdge) {
                        if (tempVector.z < -0.1) { 
                           tempVector.z = Math.min(tempVector.z + 0.1, 0); 
                        }
                        positionAttribute.setXYZ(i, tempVector.x, tempVector.y, tempVector.z);
                    }
                }
                glazeGeometry.attributes.position.needsUpdate = true;
                glazeGeometry.computeVertexNormals(); 

                glazeMaterial = new THREE.MeshStandardMaterial({
                    color: glazeColors[currentGlazeColorIndex],
                    roughness: 0.2,  
                    metalness: 0.1,  
                    transparent: true,
                    opacity: 0.85    
                });
                const glaze = new THREE.Mesh(glazeGeometry, glazeMaterial);
                glaze.position.z = 0.05; 
                donutGroup.add(glaze);

                // Sprinkles (Initial creation)
                createSprinkles(); // Refactored to a separate function
                
                scene.add(donutGroup);

                // Add pointer listeners for Glazery
                dom.glazery.canvas.addEventListener('pointerdown', onPointerDown);
                dom.glazery.canvas.addEventListener('pointermove', onPointerMove);
                dom.glazery.canvas.addEventListener('pointerup', onPointerUp);
                dom.glazery.canvas.addEventListener('pointerleave', onPointerUp);
                dom.glazery.canvas.addEventListener('wheel', onMouseWheel, { passive: false });
                
                // Setup zoom slider
                dom.glazery.zoomSlider.min = MIN_ZOOM_Z;
                dom.glazery.zoomSlider.max = MAX_ZOOM_Z;
                dom.glazery.zoomSlider.value = currentCameraZ;
                dom.glazery.zoomSlider.step = 0.1;

                isThreeJSInitialized = true; 
            }

            function createSprinkles() {
                // Remove existing sprinkles if any
                sprinkleMeshes.forEach(sprinkle => donutGroup.remove(sprinkle));
                sprinkleMeshes = [];

                const currentColors = sprinkleColorSets[currentSprinkleColorSetIndex];

                const sprinkleShape = new THREE.CylinderGeometry(0.06, 0.06, 0.4, 8); 
                const numSprinkles = 800; 
                const R_sprinkle = 2.8; 
                const r_sprinkle = 1.3 * 0.9; 

                for (let i = 0; i < numSprinkles; i++) {
                    const color = currentColors[Math.floor(Math.random() * currentColors.length)];
                    const sprinkleMaterial = new THREE.MeshStandardMaterial({ color: color });
                    const sprinkle = new THREE.Mesh(sprinkleShape, sprinkleMaterial);
                    const u = Math.random() * 2 * Math.PI; 
                    const v = Math.random() * 2 * Math.PI; 
                    
                    sprinkle.position.x = (R_sprinkle + r_sprinkle * Math.cos(u)) * Math.cos(v);
                    sprinkle.position.y = (R_sprinkle + r_sprinkle * Math.cos(u)) * Math.sin(v);
                    sprinkle.position.z = r_sprinkle * Math.sin(u);

                    if (sprinkle.position.z < -0.2 * 1.3) { 
                        continue; 
                    }

                    const centerOfTubeCrossSection = new THREE.Vector3(R_sprinkle * Math.cos(v), R_sprinkle * Math.sin(v), 0);
                    const normal = new THREE.Vector3().subVectors(sprinkle.position, centerOfTubeCrossSection).normalize();
                    sprinkle.position.addScaledVector(normal, 0.12); 
                    sprinkle.lookAt(new THREE.Vector3().addVectors(sprinkle.position, normal));
                    sprinkle.rotateX(Math.PI / 2); 
                    sprinkle.rotation.z += Math.random() * Math.PI; 
                    donutGroup.add(sprinkle);
                    sprinkleMeshes.push(sprinkle); // Store reference
                }
            }


            // ===============================================================
            // UNIVERSAL 3D CONTROLS & ANIMATION
            // ===============================================================

            function onResize() {
                // Resize Glazery Canvas
                if (renderer && camera && dom.glazery.rainContainer) {
                    const container = dom.glazery.rainContainer;
                    const w = container.clientWidth;
                    const h = container.clientHeight;
                    if (w > 0 && h > 0) {
                        camera.aspect = w / h;
                        camera.updateProjectionMatrix();
                        renderer.setSize(w, h);
                    }
                }
            }
            window.addEventListener('resize', onResize);

            function animate() {
                requestAnimationFrame(animate);
                
                // Render Glazery if active - REMOVED activeView check
                if (donutGroup && renderer) {
                    // MODIFIED: Always spin based on donutSpinSpeed, remove isDragging check
                    donutGroup.rotation.y += donutSpinSpeed; 
                    
                    // NEW: Add damping/friction to slow the spin down
                    if (donutSpinSpeed > 0.005) {
                        donutSpinSpeed *= 0.95; // Apply friction
                        // If it gets very close to the base speed, clamp it
                        if (donutSpinSpeed < 0.006) {
                            donutSpinSpeed = 0.005;
                        }
                    }
                    
                    renderer.render(scene, camera);
                }
            }

            // --- Glazery (Donut) Pointer Events ---
            let pointers = [];

            function getPinchDistance(e) {
                if (e.touches && e.touches.length === 2) {
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    return Math.sqrt(dx * dx + dy * dy);
                }
                return 0;
            }

            function onPointerDown(e) {
                pointers.push(e);
                if (pointers.length === 1) {
                    isDragging = true;
                    previousPointerX = e.clientX;
                    previousPointerY = e.clientY;
                }
                // Removed else if for two fingers to simplify interaction to only rotation/zoom on the donut
                dom.glazery.canvas.setPointerCapture(e.pointerId);
            }

            function onPointerMove(e) {
                const index = pointers.findIndex(p => p.pointerId === e.pointerId);
                if (index > -1) {
                    pointers[index] = e;
                }

                if (pointers.length === 2 && initialPinchDistance > 0) {
                    const currentPinchDistance = getPinchDistance(e);
                    if (currentPinchDistance === 0) return;
                    
                    const zoomFactor = initialPinchDistance / currentPinchDistance;
                    let newZ = currentCameraZ * zoomFactor;
                    
                    newZ = Math.max(MIN_ZOOM_Z, Math.min(MAX_ZOOM_Z, newZ));
                    camera.position.z = newZ;
                    camera.updateProjectionMatrix();
                    dom.glazery.zoomSlider.value = newZ;

                    initialPinchDistance = currentPinchDistance;
                    currentCameraZ = newZ;

                }
                // MODIFIED: Allow rotation with one finger even if another is still down (pinch ended)
                if (isDragging && pointers.length === 1) { 
                    const deltaX = e.clientX - previousPointerX;
                    const deltaY = e.clientY - previousPointerY;
                    
                    donutGroup.rotation.y += deltaX * 0.01;
                    donutGroup.rotation.x += deltaY * 0.01;
                    
                    previousPointerX = e.clientX;
                    previousPointerY = e.clientY;
                }
            }

            function onPointerUp(e) {
                pointers = pointers.filter(p => p.pointerId !== e.pointerId);
                dom.glazery.canvas.releasePointerCapture(e.pointerId);

                // No longer perform action on up, just stop dragging
                if (isDragging && pointers.length === 0) {
                    isDragging = false;
                }

                if (pointers.length < 2) {
                    initialPinchDistance = 0;
                }
            }

            function onMouseWheel(e) {
                e.preventDefault();
                let newZ = currentCameraZ + e.deltaY * 0.02;
                newZ = Math.max(MIN_ZOOM_Z, Math.min(MAX_ZOOM_Z, newZ));
                camera.position.z = newZ;
                camera.updateProjectionMatrix();
                dom.glazery.zoomSlider.value = newZ;
                currentCameraZ = newZ;
            }

            function changeGlazeColor() {
                if (glazeMaterial) {
                    currentGlazeColorIndex = (currentGlazeColorIndex + 1) % glazeColors.length;
                    glazeMaterial.color.set(glazeColors[currentGlazeColorIndex]);
                }
            }

            function changeDonutBaseColor() { // NEW
                if (donutMaterial) {
                    currentDonutBaseColorIndex = (currentDonutBaseColorIndex + 1) % donutBaseColors.length;
                    const newColorOrMode = donutBaseColors[currentDonutBaseColorIndex];

                    if (newColorOrMode === null) {
                        // Activate wireframe mode
                        donutMaterial.wireframe = true;
                        // Set wireframe color to something visible (e.g., light cream, matches dark mode text)
                        donutMaterial.color.set(0xF5E6C1); 
                    } else {
                        // Activate solid mode
                        donutMaterial.wireframe = false;
                        donutMaterial.color.set(newColorOrMode);
                    }
                }
            }

            function changeSprinkleColor() { // NEW
                currentSprinkleColorSetIndex = (currentSprinkleColorSetIndex + 1) % sprinkleColorSets.length;
                createSprinkles(); // Recreate sprinkles with new color set
            }


            // ===============================================================
            // RENDER/UPDATE FUNCTIONS
            // ===============================================================

            const updateUI = () => {
                // NEW: Calculate percentMined globally for both views
                const { totalDonutSupply, totalCookiesCreated, nextHalvingAt, totalMiners } = state.global;
                const percentMined = totalDonutSupply > 0 ? (totalCookiesCreated / totalDonutSupply) * 100 : 0;

                // Update Glazery View (always, since it's the main view)
                
                // NEW: Update second row of stats
                dom.glazery.donutBalance.textContent = '🍩 ' + format(state.player.cookies);
                dom.glazery.totalGlazeTime.textContent = formatGlazeTime(state.player.totalGlazeTimeMs);
                dom.glazery.percentMined.textContent = formatDecimal(percentMined);

                // --- Update first row of stats ---
                const bakeryCps = state.player.isBakerKing ? state.global.emissionRate : 0; 
                dom.glazery.cps.textContent = formatDecimal(bakeryCps);
                
                if (state.player.isBakerKing && state.player.glazeStartTime) {
                    const elapsedMs = Date.now() - state.player.glazeStartTime;
                    dom.glazery.baked.textContent = formatGlazeTime(elapsedMs);
                } else {
                    dom.glazery.baked.textContent = '00:00:00';
                }
                
                const claimableBakery = Math.floor(state.player.claimableBakeryCookies);
                if (state.player.isBakerKing) {
                    dom.glazery.kingStatus.textContent = 'You';
                    dom.glazery.actionButton.textContent = `Bake ${format(claimableBakery)}`;
                    dom.glazery.actionButton.disabled = claimableBakery < 1;
                } else {
                    dom.glazery.kingStatus.textContent = 'None';
                    dom.glazery.actionButton.textContent = 'Glaze';
                    dom.glazery.actionButton.disabled = false;
                }
                
                // NEW: Calculate halving time (used in two places)
                const blocksRemaining = nextHalvingAt - totalCookiesCreated;
                const secondsRemaining = Math.max(0, Math.floor(blocksRemaining * (GAME_TICK_MS / 100))); 
                const hours = Math.floor(secondsRemaining / 3600);
                const minutes = Math.floor((secondsRemaining % 3600) / 60);
                const seconds = secondsRemaining % 60;
                const halvingTimeText = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;

                // Update About Page Stats - REMOVED this entire block
                
                // NEW: Update Modal Stats (always, so it's fresh when opened)
                if (dom.modalInfo.totalSupply) { // Check if elements exist
                    dom.modalInfo.totalSupply.textContent = `🍩 ${format(totalDonutSupply)}`;
                    dom.modalInfo.percentMined.textContent = `${formatDecimal(percentMined)}%`;
                    dom.modalInfo.nextHalving.textContent = halvingTimeText;
                    dom.modalInfo.totalMiners.textContent = `👤 ${format(totalMiners)}`;
                }
            };
            
            // REMOVED showView function

            // ===============================================================
            // GAME ACTIONS (NEW SECTION)
            // ===============================================================

            const handleMinerAction = () => {
                donutSpinSpeed = 0.5; // NEW: Set spin speed to high!

                if (state.player.isBakerKing) {
                    // Claim "Bake"
                    const claimable = Math.floor(state.player.claimableBakeryCookies);
                    if (claimable > 0) {
                        playSoundEffect('purchase');
                        state.player.cookies += claimable;
                        state.player.totalBakedCookies += claimable;
                        state.player.claimableBakeryCookies = 0;
                        console.log(`Claimed ${claimable} cookies.`);
                    }
                } else {
                    // Redirect to payment frame to become "Glazer" (King)
                    playSoundEffect('purchase');
                    window.location.href = 'https://last-game-kappa.vercel.app/api/payment-frame';
                }
                
                updateUI();
            };

            // ===============================================================
            // GAME LOOP
            // ===============================================================
            
            const GAME_TICK_MS = 100;

            const gameLoop = () => {
                // MOCK: Increment total mined cookies for countdown demo
                state.global.totalCookiesCreated += state.global.emissionRate * (GAME_TICK_MS / 1000);
                
                // MOCK: Increment claimable cookies if king
                if (state.player.isBakerKing) {
                    const bakeryCps = state.global.emissionRate;
                    state.player.claimableBakeryCookies += bakeryCps * (GAME_TICK_MS / 1000);
                    state.player.totalGlazeTimeMs += GAME_TICK_MS; // NEW: Increment total glaze time
                }
                
                updateUI();
            };

            // ===============================================================
            // INITIALIZATION
            // ===============================================================
            
            // REMOVED nav listeners
            dom.glazery.actionButton.onclick = handleMinerAction;
            dom.musicToggleButton.onclick = toggleMusic;
            dom.sfxToggleButton.onclick = toggleSfx;
            dom.darkModeToggleButton.onclick = () => {
                playSoundEffect('crunch');
                toggleDarkMode();
            };
            dom.glazery.glazeColorButton.onclick = () => {
                playSoundEffect('crunch');
                changeGlazeColor();
            };
            dom.glazery.sprinkleColorButton.onclick = () => { // NEW
                playSoundEffect('crunch');
                changeSprinkleColor();
            };
            dom.glazery.donutBaseColorButton.onclick = () => { // NEW
                playSoundEffect('crunch');
                changeDonutBaseColor();
            };

            // NEW MODAL LISTENERS
            dom.infoButton.onclick = showInfoModal;
            dom.infoModalClose.onclick = hideInfoModal;
            dom.infoModalOverlay.onclick = hideInfoModal;

            dom.glazery.zoomSlider.oninput = () => {
                if (!isThreeJSInitialized) return;
                const newZ = parseFloat(dom.glazery.zoomSlider.value);
                camera.position.z = newZ;
                camera.updateProjectionMatrix();
                currentCameraZ = newZ;
            };

            // REMOVED showView('glazery');
            setInterval(gameLoop, GAME_TICK_MS);
            
            if (!isThreeJSInitialized) {
                setTimeout(initThreeJS, 0); 
            }
            
            animate();


            // ===============================================================
            // FETCH GLAZE PRICE FUNCTION (ADDED - WAS MISSING)
            // ===============================================================
            async function fetchGlazePrice() {
                try {
                    console.log('[Glaze Price] Fetching current glaze price...');
                    const response = await fetch('/api/get-price');
                    
                    if (!response.ok) {
                        console.warn(`[Glaze Price] API returned ${response.status}`);
                        return null;
                    }
                    
                    const data = await response.json();
                    
                    if (data.error) {
                        console.warn('[Glaze Price] API returned error:', data.error);
                        return null;
                    }
                    
                    // Update state with the fetched price
                    const price = parseFloat(data.priceInUsdc || '0');
                    if (!state.global) state.global = {};
                    state.global.currentGlazePrice = price;
                    
                    console.log(`[Glaze Price] Current glaze price: $${price} USDC`);
                    
                    return data;
                } catch (error) {
                    console.error('[Glaze Price] Error fetching price:', error.message);
                    return null;
                }
            }

            // ===============================================================
            // WALLET CONNECTION & PRICE FETCHING (ROBUST VERSION)
            // ===============================================================
            (async () => {
                // First, try to fetch the price (doesn't require wallet)
                await fetchGlazePrice();
                
                // Set up periodic price updates
                setInterval(fetchGlazePrice, 10000);
                
                // Now try wallet connection - but don't let failures break the app
                try {
                    console.log('[Wallet] Attempting to connect to Farcaster SDK...');
                    
                    // Set a timeout for the SDK import
                    const sdkPromise = import('https://esm.sh/@farcaster/miniapp-sdk');
                    const timeoutPromise = new Promise((_, reject) => 
                        setTimeout(() => reject(new Error('SDK import timeout')), 5000)
                    );
                    
                    const { default: sdk } = await Promise.race([sdkPromise, timeoutPromise]);
                    
                    console.log('[Wallet] SDK loaded, calling ready()...');
                    await sdk.actions.ready();
                    
                    console.log('[Wallet] Getting Ethereum provider...');
                    const provider = await sdk.wallet.getEthereumProvider();
                    
                    if (provider) {
                        console.log('[Wallet] Provider found, requesting accounts...');
                        const accounts = await provider.request({ method: 'eth_requestAccounts' });
                        console.log('[Wallet] Connected successfully:', accounts[0]);
                    } else {
                        console.log('[Wallet] No provider available - running outside miniapp context');
                    }
                } catch (error) {
                    // Don't throw - just log and continue
                    console.log('[Wallet] Could not connect (this is OK if testing outside Farcaster):', error.message);
                    console.log('[Wallet] Game will continue to work, but payment features require Farcaster miniapp');
                }
            })();
        });
    </script>
</body>
</html>
